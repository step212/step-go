// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"step/internal/data/ent/migrate"

	"step/internal/data/ent/award"
	"step/internal/data/ent/portrait"
	"step/internal/data/ent/show"
	"step/internal/data/ent/showreserve"
	"step/internal/data/ent/step"
	"step/internal/data/ent/steprate"
	"step/internal/data/ent/target"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Award is the client for interacting with the Award builders.
	Award *AwardClient
	// Portrait is the client for interacting with the Portrait builders.
	Portrait *PortraitClient
	// Show is the client for interacting with the Show builders.
	Show *ShowClient
	// ShowReserve is the client for interacting with the ShowReserve builders.
	ShowReserve *ShowReserveClient
	// Step is the client for interacting with the Step builders.
	Step *StepClient
	// StepRate is the client for interacting with the StepRate builders.
	StepRate *StepRateClient
	// Target is the client for interacting with the Target builders.
	Target *TargetClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Award = NewAwardClient(c.config)
	c.Portrait = NewPortraitClient(c.config)
	c.Show = NewShowClient(c.config)
	c.ShowReserve = NewShowReserveClient(c.config)
	c.Step = NewStepClient(c.config)
	c.StepRate = NewStepRateClient(c.config)
	c.Target = NewTargetClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:         ctx,
		config:      cfg,
		Award:       NewAwardClient(cfg),
		Portrait:    NewPortraitClient(cfg),
		Show:        NewShowClient(cfg),
		ShowReserve: NewShowReserveClient(cfg),
		Step:        NewStepClient(cfg),
		StepRate:    NewStepRateClient(cfg),
		Target:      NewTargetClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:         ctx,
		config:      cfg,
		Award:       NewAwardClient(cfg),
		Portrait:    NewPortraitClient(cfg),
		Show:        NewShowClient(cfg),
		ShowReserve: NewShowReserveClient(cfg),
		Step:        NewStepClient(cfg),
		StepRate:    NewStepRateClient(cfg),
		Target:      NewTargetClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Award.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Award, c.Portrait, c.Show, c.ShowReserve, c.Step, c.StepRate, c.Target,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Award, c.Portrait, c.Show, c.ShowReserve, c.Step, c.StepRate, c.Target,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AwardMutation:
		return c.Award.mutate(ctx, m)
	case *PortraitMutation:
		return c.Portrait.mutate(ctx, m)
	case *ShowMutation:
		return c.Show.mutate(ctx, m)
	case *ShowReserveMutation:
		return c.ShowReserve.mutate(ctx, m)
	case *StepMutation:
		return c.Step.mutate(ctx, m)
	case *StepRateMutation:
		return c.StepRate.mutate(ctx, m)
	case *TargetMutation:
		return c.Target.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AwardClient is a client for the Award schema.
type AwardClient struct {
	config
}

// NewAwardClient returns a client for the Award from the given config.
func NewAwardClient(c config) *AwardClient {
	return &AwardClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `award.Hooks(f(g(h())))`.
func (c *AwardClient) Use(hooks ...Hook) {
	c.hooks.Award = append(c.hooks.Award, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `award.Intercept(f(g(h())))`.
func (c *AwardClient) Intercept(interceptors ...Interceptor) {
	c.inters.Award = append(c.inters.Award, interceptors...)
}

// Create returns a builder for creating a Award entity.
func (c *AwardClient) Create() *AwardCreate {
	mutation := newAwardMutation(c.config, OpCreate)
	return &AwardCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Award entities.
func (c *AwardClient) CreateBulk(builders ...*AwardCreate) *AwardCreateBulk {
	return &AwardCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AwardClient) MapCreateBulk(slice any, setFunc func(*AwardCreate, int)) *AwardCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AwardCreateBulk{err: fmt.Errorf("calling to AwardClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AwardCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AwardCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Award.
func (c *AwardClient) Update() *AwardUpdate {
	mutation := newAwardMutation(c.config, OpUpdate)
	return &AwardUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AwardClient) UpdateOne(a *Award) *AwardUpdateOne {
	mutation := newAwardMutation(c.config, OpUpdateOne, withAward(a))
	return &AwardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AwardClient) UpdateOneID(id uint64) *AwardUpdateOne {
	mutation := newAwardMutation(c.config, OpUpdateOne, withAwardID(id))
	return &AwardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Award.
func (c *AwardClient) Delete() *AwardDelete {
	mutation := newAwardMutation(c.config, OpDelete)
	return &AwardDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AwardClient) DeleteOne(a *Award) *AwardDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AwardClient) DeleteOneID(id uint64) *AwardDeleteOne {
	builder := c.Delete().Where(award.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AwardDeleteOne{builder}
}

// Query returns a query builder for Award.
func (c *AwardClient) Query() *AwardQuery {
	return &AwardQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAward},
		inters: c.Interceptors(),
	}
}

// Get returns a Award entity by its id.
func (c *AwardClient) Get(ctx context.Context, id uint64) (*Award, error) {
	return c.Query().Where(award.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AwardClient) GetX(ctx context.Context, id uint64) *Award {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AwardClient) Hooks() []Hook {
	return c.hooks.Award
}

// Interceptors returns the client interceptors.
func (c *AwardClient) Interceptors() []Interceptor {
	return c.inters.Award
}

func (c *AwardClient) mutate(ctx context.Context, m *AwardMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AwardCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AwardUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AwardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AwardDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Award mutation op: %q", m.Op())
	}
}

// PortraitClient is a client for the Portrait schema.
type PortraitClient struct {
	config
}

// NewPortraitClient returns a client for the Portrait from the given config.
func NewPortraitClient(c config) *PortraitClient {
	return &PortraitClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `portrait.Hooks(f(g(h())))`.
func (c *PortraitClient) Use(hooks ...Hook) {
	c.hooks.Portrait = append(c.hooks.Portrait, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `portrait.Intercept(f(g(h())))`.
func (c *PortraitClient) Intercept(interceptors ...Interceptor) {
	c.inters.Portrait = append(c.inters.Portrait, interceptors...)
}

// Create returns a builder for creating a Portrait entity.
func (c *PortraitClient) Create() *PortraitCreate {
	mutation := newPortraitMutation(c.config, OpCreate)
	return &PortraitCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Portrait entities.
func (c *PortraitClient) CreateBulk(builders ...*PortraitCreate) *PortraitCreateBulk {
	return &PortraitCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PortraitClient) MapCreateBulk(slice any, setFunc func(*PortraitCreate, int)) *PortraitCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PortraitCreateBulk{err: fmt.Errorf("calling to PortraitClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PortraitCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PortraitCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Portrait.
func (c *PortraitClient) Update() *PortraitUpdate {
	mutation := newPortraitMutation(c.config, OpUpdate)
	return &PortraitUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PortraitClient) UpdateOne(po *Portrait) *PortraitUpdateOne {
	mutation := newPortraitMutation(c.config, OpUpdateOne, withPortrait(po))
	return &PortraitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PortraitClient) UpdateOneID(id uint64) *PortraitUpdateOne {
	mutation := newPortraitMutation(c.config, OpUpdateOne, withPortraitID(id))
	return &PortraitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Portrait.
func (c *PortraitClient) Delete() *PortraitDelete {
	mutation := newPortraitMutation(c.config, OpDelete)
	return &PortraitDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PortraitClient) DeleteOne(po *Portrait) *PortraitDeleteOne {
	return c.DeleteOneID(po.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PortraitClient) DeleteOneID(id uint64) *PortraitDeleteOne {
	builder := c.Delete().Where(portrait.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PortraitDeleteOne{builder}
}

// Query returns a query builder for Portrait.
func (c *PortraitClient) Query() *PortraitQuery {
	return &PortraitQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePortrait},
		inters: c.Interceptors(),
	}
}

// Get returns a Portrait entity by its id.
func (c *PortraitClient) Get(ctx context.Context, id uint64) (*Portrait, error) {
	return c.Query().Where(portrait.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PortraitClient) GetX(ctx context.Context, id uint64) *Portrait {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PortraitClient) Hooks() []Hook {
	return c.hooks.Portrait
}

// Interceptors returns the client interceptors.
func (c *PortraitClient) Interceptors() []Interceptor {
	return c.inters.Portrait
}

func (c *PortraitClient) mutate(ctx context.Context, m *PortraitMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PortraitCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PortraitUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PortraitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PortraitDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Portrait mutation op: %q", m.Op())
	}
}

// ShowClient is a client for the Show schema.
type ShowClient struct {
	config
}

// NewShowClient returns a client for the Show from the given config.
func NewShowClient(c config) *ShowClient {
	return &ShowClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `show.Hooks(f(g(h())))`.
func (c *ShowClient) Use(hooks ...Hook) {
	c.hooks.Show = append(c.hooks.Show, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `show.Intercept(f(g(h())))`.
func (c *ShowClient) Intercept(interceptors ...Interceptor) {
	c.inters.Show = append(c.inters.Show, interceptors...)
}

// Create returns a builder for creating a Show entity.
func (c *ShowClient) Create() *ShowCreate {
	mutation := newShowMutation(c.config, OpCreate)
	return &ShowCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Show entities.
func (c *ShowClient) CreateBulk(builders ...*ShowCreate) *ShowCreateBulk {
	return &ShowCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ShowClient) MapCreateBulk(slice any, setFunc func(*ShowCreate, int)) *ShowCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ShowCreateBulk{err: fmt.Errorf("calling to ShowClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ShowCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ShowCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Show.
func (c *ShowClient) Update() *ShowUpdate {
	mutation := newShowMutation(c.config, OpUpdate)
	return &ShowUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ShowClient) UpdateOne(s *Show) *ShowUpdateOne {
	mutation := newShowMutation(c.config, OpUpdateOne, withShow(s))
	return &ShowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ShowClient) UpdateOneID(id uint64) *ShowUpdateOne {
	mutation := newShowMutation(c.config, OpUpdateOne, withShowID(id))
	return &ShowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Show.
func (c *ShowClient) Delete() *ShowDelete {
	mutation := newShowMutation(c.config, OpDelete)
	return &ShowDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ShowClient) DeleteOne(s *Show) *ShowDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ShowClient) DeleteOneID(id uint64) *ShowDeleteOne {
	builder := c.Delete().Where(show.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ShowDeleteOne{builder}
}

// Query returns a query builder for Show.
func (c *ShowClient) Query() *ShowQuery {
	return &ShowQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeShow},
		inters: c.Interceptors(),
	}
}

// Get returns a Show entity by its id.
func (c *ShowClient) Get(ctx context.Context, id uint64) (*Show, error) {
	return c.Query().Where(show.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ShowClient) GetX(ctx context.Context, id uint64) *Show {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryShowReserves queries the show_reserves edge of a Show.
func (c *ShowClient) QueryShowReserves(s *Show) *ShowReserveQuery {
	query := (&ShowReserveClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(show.Table, show.FieldID, id),
			sqlgraph.To(showreserve.Table, showreserve.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, show.ShowReservesTable, show.ShowReservesColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ShowClient) Hooks() []Hook {
	return c.hooks.Show
}

// Interceptors returns the client interceptors.
func (c *ShowClient) Interceptors() []Interceptor {
	return c.inters.Show
}

func (c *ShowClient) mutate(ctx context.Context, m *ShowMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ShowCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ShowUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ShowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ShowDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Show mutation op: %q", m.Op())
	}
}

// ShowReserveClient is a client for the ShowReserve schema.
type ShowReserveClient struct {
	config
}

// NewShowReserveClient returns a client for the ShowReserve from the given config.
func NewShowReserveClient(c config) *ShowReserveClient {
	return &ShowReserveClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `showreserve.Hooks(f(g(h())))`.
func (c *ShowReserveClient) Use(hooks ...Hook) {
	c.hooks.ShowReserve = append(c.hooks.ShowReserve, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `showreserve.Intercept(f(g(h())))`.
func (c *ShowReserveClient) Intercept(interceptors ...Interceptor) {
	c.inters.ShowReserve = append(c.inters.ShowReserve, interceptors...)
}

// Create returns a builder for creating a ShowReserve entity.
func (c *ShowReserveClient) Create() *ShowReserveCreate {
	mutation := newShowReserveMutation(c.config, OpCreate)
	return &ShowReserveCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ShowReserve entities.
func (c *ShowReserveClient) CreateBulk(builders ...*ShowReserveCreate) *ShowReserveCreateBulk {
	return &ShowReserveCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ShowReserveClient) MapCreateBulk(slice any, setFunc func(*ShowReserveCreate, int)) *ShowReserveCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ShowReserveCreateBulk{err: fmt.Errorf("calling to ShowReserveClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ShowReserveCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ShowReserveCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ShowReserve.
func (c *ShowReserveClient) Update() *ShowReserveUpdate {
	mutation := newShowReserveMutation(c.config, OpUpdate)
	return &ShowReserveUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ShowReserveClient) UpdateOne(sr *ShowReserve) *ShowReserveUpdateOne {
	mutation := newShowReserveMutation(c.config, OpUpdateOne, withShowReserve(sr))
	return &ShowReserveUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ShowReserveClient) UpdateOneID(id uint64) *ShowReserveUpdateOne {
	mutation := newShowReserveMutation(c.config, OpUpdateOne, withShowReserveID(id))
	return &ShowReserveUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ShowReserve.
func (c *ShowReserveClient) Delete() *ShowReserveDelete {
	mutation := newShowReserveMutation(c.config, OpDelete)
	return &ShowReserveDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ShowReserveClient) DeleteOne(sr *ShowReserve) *ShowReserveDeleteOne {
	return c.DeleteOneID(sr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ShowReserveClient) DeleteOneID(id uint64) *ShowReserveDeleteOne {
	builder := c.Delete().Where(showreserve.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ShowReserveDeleteOne{builder}
}

// Query returns a query builder for ShowReserve.
func (c *ShowReserveClient) Query() *ShowReserveQuery {
	return &ShowReserveQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeShowReserve},
		inters: c.Interceptors(),
	}
}

// Get returns a ShowReserve entity by its id.
func (c *ShowReserveClient) Get(ctx context.Context, id uint64) (*ShowReserve, error) {
	return c.Query().Where(showreserve.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ShowReserveClient) GetX(ctx context.Context, id uint64) *ShowReserve {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryShow queries the show edge of a ShowReserve.
func (c *ShowReserveClient) QueryShow(sr *ShowReserve) *ShowQuery {
	query := (&ShowClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(showreserve.Table, showreserve.FieldID, id),
			sqlgraph.To(show.Table, show.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, showreserve.ShowTable, showreserve.ShowColumn),
		)
		fromV = sqlgraph.Neighbors(sr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ShowReserveClient) Hooks() []Hook {
	return c.hooks.ShowReserve
}

// Interceptors returns the client interceptors.
func (c *ShowReserveClient) Interceptors() []Interceptor {
	return c.inters.ShowReserve
}

func (c *ShowReserveClient) mutate(ctx context.Context, m *ShowReserveMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ShowReserveCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ShowReserveUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ShowReserveUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ShowReserveDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ShowReserve mutation op: %q", m.Op())
	}
}

// StepClient is a client for the Step schema.
type StepClient struct {
	config
}

// NewStepClient returns a client for the Step from the given config.
func NewStepClient(c config) *StepClient {
	return &StepClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `step.Hooks(f(g(h())))`.
func (c *StepClient) Use(hooks ...Hook) {
	c.hooks.Step = append(c.hooks.Step, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `step.Intercept(f(g(h())))`.
func (c *StepClient) Intercept(interceptors ...Interceptor) {
	c.inters.Step = append(c.inters.Step, interceptors...)
}

// Create returns a builder for creating a Step entity.
func (c *StepClient) Create() *StepCreate {
	mutation := newStepMutation(c.config, OpCreate)
	return &StepCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Step entities.
func (c *StepClient) CreateBulk(builders ...*StepCreate) *StepCreateBulk {
	return &StepCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StepClient) MapCreateBulk(slice any, setFunc func(*StepCreate, int)) *StepCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StepCreateBulk{err: fmt.Errorf("calling to StepClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StepCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StepCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Step.
func (c *StepClient) Update() *StepUpdate {
	mutation := newStepMutation(c.config, OpUpdate)
	return &StepUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StepClient) UpdateOne(s *Step) *StepUpdateOne {
	mutation := newStepMutation(c.config, OpUpdateOne, withStep(s))
	return &StepUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StepClient) UpdateOneID(id uint64) *StepUpdateOne {
	mutation := newStepMutation(c.config, OpUpdateOne, withStepID(id))
	return &StepUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Step.
func (c *StepClient) Delete() *StepDelete {
	mutation := newStepMutation(c.config, OpDelete)
	return &StepDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StepClient) DeleteOne(s *Step) *StepDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StepClient) DeleteOneID(id uint64) *StepDeleteOne {
	builder := c.Delete().Where(step.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StepDeleteOne{builder}
}

// Query returns a query builder for Step.
func (c *StepClient) Query() *StepQuery {
	return &StepQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStep},
		inters: c.Interceptors(),
	}
}

// Get returns a Step entity by its id.
func (c *StepClient) Get(ctx context.Context, id uint64) (*Step, error) {
	return c.Query().Where(step.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StepClient) GetX(ctx context.Context, id uint64) *Step {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTarget queries the target edge of a Step.
func (c *StepClient) QueryTarget(s *Step) *TargetQuery {
	query := (&TargetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(step.Table, step.FieldID, id),
			sqlgraph.To(target.Table, target.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, step.TargetTable, step.TargetColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a Step.
func (c *StepClient) QueryParent(s *Step) *StepQuery {
	query := (&StepClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(step.Table, step.FieldID, id),
			sqlgraph.To(step.Table, step.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, step.ParentTable, step.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Step.
func (c *StepClient) QueryChildren(s *Step) *StepQuery {
	query := (&StepClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(step.Table, step.FieldID, id),
			sqlgraph.To(step.Table, step.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, step.ChildrenTable, step.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StepClient) Hooks() []Hook {
	return c.hooks.Step
}

// Interceptors returns the client interceptors.
func (c *StepClient) Interceptors() []Interceptor {
	return c.inters.Step
}

func (c *StepClient) mutate(ctx context.Context, m *StepMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StepCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StepUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StepUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StepDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Step mutation op: %q", m.Op())
	}
}

// StepRateClient is a client for the StepRate schema.
type StepRateClient struct {
	config
}

// NewStepRateClient returns a client for the StepRate from the given config.
func NewStepRateClient(c config) *StepRateClient {
	return &StepRateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `steprate.Hooks(f(g(h())))`.
func (c *StepRateClient) Use(hooks ...Hook) {
	c.hooks.StepRate = append(c.hooks.StepRate, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `steprate.Intercept(f(g(h())))`.
func (c *StepRateClient) Intercept(interceptors ...Interceptor) {
	c.inters.StepRate = append(c.inters.StepRate, interceptors...)
}

// Create returns a builder for creating a StepRate entity.
func (c *StepRateClient) Create() *StepRateCreate {
	mutation := newStepRateMutation(c.config, OpCreate)
	return &StepRateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of StepRate entities.
func (c *StepRateClient) CreateBulk(builders ...*StepRateCreate) *StepRateCreateBulk {
	return &StepRateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StepRateClient) MapCreateBulk(slice any, setFunc func(*StepRateCreate, int)) *StepRateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StepRateCreateBulk{err: fmt.Errorf("calling to StepRateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StepRateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StepRateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for StepRate.
func (c *StepRateClient) Update() *StepRateUpdate {
	mutation := newStepRateMutation(c.config, OpUpdate)
	return &StepRateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StepRateClient) UpdateOne(sr *StepRate) *StepRateUpdateOne {
	mutation := newStepRateMutation(c.config, OpUpdateOne, withStepRate(sr))
	return &StepRateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StepRateClient) UpdateOneID(id uint64) *StepRateUpdateOne {
	mutation := newStepRateMutation(c.config, OpUpdateOne, withStepRateID(id))
	return &StepRateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for StepRate.
func (c *StepRateClient) Delete() *StepRateDelete {
	mutation := newStepRateMutation(c.config, OpDelete)
	return &StepRateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StepRateClient) DeleteOne(sr *StepRate) *StepRateDeleteOne {
	return c.DeleteOneID(sr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StepRateClient) DeleteOneID(id uint64) *StepRateDeleteOne {
	builder := c.Delete().Where(steprate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StepRateDeleteOne{builder}
}

// Query returns a query builder for StepRate.
func (c *StepRateClient) Query() *StepRateQuery {
	return &StepRateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStepRate},
		inters: c.Interceptors(),
	}
}

// Get returns a StepRate entity by its id.
func (c *StepRateClient) Get(ctx context.Context, id uint64) (*StepRate, error) {
	return c.Query().Where(steprate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StepRateClient) GetX(ctx context.Context, id uint64) *StepRate {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *StepRateClient) Hooks() []Hook {
	return c.hooks.StepRate
}

// Interceptors returns the client interceptors.
func (c *StepRateClient) Interceptors() []Interceptor {
	return c.inters.StepRate
}

func (c *StepRateClient) mutate(ctx context.Context, m *StepRateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StepRateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StepRateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StepRateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StepRateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown StepRate mutation op: %q", m.Op())
	}
}

// TargetClient is a client for the Target schema.
type TargetClient struct {
	config
}

// NewTargetClient returns a client for the Target from the given config.
func NewTargetClient(c config) *TargetClient {
	return &TargetClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `target.Hooks(f(g(h())))`.
func (c *TargetClient) Use(hooks ...Hook) {
	c.hooks.Target = append(c.hooks.Target, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `target.Intercept(f(g(h())))`.
func (c *TargetClient) Intercept(interceptors ...Interceptor) {
	c.inters.Target = append(c.inters.Target, interceptors...)
}

// Create returns a builder for creating a Target entity.
func (c *TargetClient) Create() *TargetCreate {
	mutation := newTargetMutation(c.config, OpCreate)
	return &TargetCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Target entities.
func (c *TargetClient) CreateBulk(builders ...*TargetCreate) *TargetCreateBulk {
	return &TargetCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TargetClient) MapCreateBulk(slice any, setFunc func(*TargetCreate, int)) *TargetCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TargetCreateBulk{err: fmt.Errorf("calling to TargetClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TargetCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TargetCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Target.
func (c *TargetClient) Update() *TargetUpdate {
	mutation := newTargetMutation(c.config, OpUpdate)
	return &TargetUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TargetClient) UpdateOne(t *Target) *TargetUpdateOne {
	mutation := newTargetMutation(c.config, OpUpdateOne, withTarget(t))
	return &TargetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TargetClient) UpdateOneID(id uint64) *TargetUpdateOne {
	mutation := newTargetMutation(c.config, OpUpdateOne, withTargetID(id))
	return &TargetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Target.
func (c *TargetClient) Delete() *TargetDelete {
	mutation := newTargetMutation(c.config, OpDelete)
	return &TargetDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TargetClient) DeleteOne(t *Target) *TargetDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TargetClient) DeleteOneID(id uint64) *TargetDeleteOne {
	builder := c.Delete().Where(target.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TargetDeleteOne{builder}
}

// Query returns a query builder for Target.
func (c *TargetClient) Query() *TargetQuery {
	return &TargetQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTarget},
		inters: c.Interceptors(),
	}
}

// Get returns a Target entity by its id.
func (c *TargetClient) Get(ctx context.Context, id uint64) (*Target, error) {
	return c.Query().Where(target.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TargetClient) GetX(ctx context.Context, id uint64) *Target {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryParent queries the parent edge of a Target.
func (c *TargetClient) QueryParent(t *Target) *TargetQuery {
	query := (&TargetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(target.Table, target.FieldID, id),
			sqlgraph.To(target.Table, target.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, target.ParentTable, target.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Target.
func (c *TargetClient) QueryChildren(t *Target) *TargetQuery {
	query := (&TargetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(target.Table, target.FieldID, id),
			sqlgraph.To(target.Table, target.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, target.ChildrenTable, target.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySteps queries the steps edge of a Target.
func (c *TargetClient) QuerySteps(t *Target) *StepQuery {
	query := (&StepClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(target.Table, target.FieldID, id),
			sqlgraph.To(step.Table, step.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, target.StepsTable, target.StepsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TargetClient) Hooks() []Hook {
	return c.hooks.Target
}

// Interceptors returns the client interceptors.
func (c *TargetClient) Interceptors() []Interceptor {
	return c.inters.Target
}

func (c *TargetClient) mutate(ctx context.Context, m *TargetMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TargetCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TargetUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TargetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TargetDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Target mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Award, Portrait, Show, ShowReserve, Step, StepRate, Target []ent.Hook
	}
	inters struct {
		Award, Portrait, Show, ShowReserve, Step, StepRate, Target []ent.Interceptor
	}
)
