// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"step/internal/data/ent/award"
	"step/internal/data/ent/portrait"
	"step/internal/data/ent/predicate"
	"step/internal/data/ent/show"
	"step/internal/data/ent/showreserve"
	"step/internal/data/ent/step"
	"step/internal/data/ent/steprate"
	"step/internal/data/ent/target"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAward       = "Award"
	TypePortrait    = "Portrait"
	TypeShow        = "Show"
	TypeShowReserve = "ShowReserve"
	TypeStep        = "Step"
	TypeStepRate    = "StepRate"
	TypeTarget      = "Target"
)

// AwardMutation represents an operation that mutates the Award nodes in the graph.
type AwardMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint64
	user_id              *string
	status               *award.Status
	description          *string
	setted_files         *[]string
	appendsetted_files   []string
	realized_files       *[]string
	appendrealized_files []string
	target_type          *award.TargetType
	scope                *string
	dimension            *string
	threshold            *int32
	addthreshold         *int32
	setted_at            *int64
	addsetted_at         *int64
	achieved_at          *int64
	addachieved_at       *int64
	realized_at          *int64
	addrealized_at       *int64
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*Award, error)
	predicates           []predicate.Award
}

var _ ent.Mutation = (*AwardMutation)(nil)

// awardOption allows management of the mutation configuration using functional options.
type awardOption func(*AwardMutation)

// newAwardMutation creates new mutation for the Award entity.
func newAwardMutation(c config, op Op, opts ...awardOption) *AwardMutation {
	m := &AwardMutation{
		config:        c,
		op:            op,
		typ:           TypeAward,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAwardID sets the ID field of the mutation.
func withAwardID(id uint64) awardOption {
	return func(m *AwardMutation) {
		var (
			err   error
			once  sync.Once
			value *Award
		)
		m.oldValue = func(ctx context.Context) (*Award, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Award.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAward sets the old Award of the mutation.
func withAward(node *Award) awardOption {
	return func(m *AwardMutation) {
		m.oldValue = func(context.Context) (*Award, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AwardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AwardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Award entities.
func (m *AwardMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AwardMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AwardMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Award.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *AwardMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AwardMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AwardMutation) ResetUserID() {
	m.user_id = nil
}

// SetStatus sets the "status" field.
func (m *AwardMutation) SetStatus(a award.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *AwardMutation) Status() (r award.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldStatus(ctx context.Context) (v award.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AwardMutation) ResetStatus() {
	m.status = nil
}

// SetDescription sets the "description" field.
func (m *AwardMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AwardMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AwardMutation) ResetDescription() {
	m.description = nil
}

// SetSettedFiles sets the "setted_files" field.
func (m *AwardMutation) SetSettedFiles(s []string) {
	m.setted_files = &s
	m.appendsetted_files = nil
}

// SettedFiles returns the value of the "setted_files" field in the mutation.
func (m *AwardMutation) SettedFiles() (r []string, exists bool) {
	v := m.setted_files
	if v == nil {
		return
	}
	return *v, true
}

// OldSettedFiles returns the old "setted_files" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldSettedFiles(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettedFiles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettedFiles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettedFiles: %w", err)
	}
	return oldValue.SettedFiles, nil
}

// AppendSettedFiles adds s to the "setted_files" field.
func (m *AwardMutation) AppendSettedFiles(s []string) {
	m.appendsetted_files = append(m.appendsetted_files, s...)
}

// AppendedSettedFiles returns the list of values that were appended to the "setted_files" field in this mutation.
func (m *AwardMutation) AppendedSettedFiles() ([]string, bool) {
	if len(m.appendsetted_files) == 0 {
		return nil, false
	}
	return m.appendsetted_files, true
}

// ClearSettedFiles clears the value of the "setted_files" field.
func (m *AwardMutation) ClearSettedFiles() {
	m.setted_files = nil
	m.appendsetted_files = nil
	m.clearedFields[award.FieldSettedFiles] = struct{}{}
}

// SettedFilesCleared returns if the "setted_files" field was cleared in this mutation.
func (m *AwardMutation) SettedFilesCleared() bool {
	_, ok := m.clearedFields[award.FieldSettedFiles]
	return ok
}

// ResetSettedFiles resets all changes to the "setted_files" field.
func (m *AwardMutation) ResetSettedFiles() {
	m.setted_files = nil
	m.appendsetted_files = nil
	delete(m.clearedFields, award.FieldSettedFiles)
}

// SetRealizedFiles sets the "realized_files" field.
func (m *AwardMutation) SetRealizedFiles(s []string) {
	m.realized_files = &s
	m.appendrealized_files = nil
}

// RealizedFiles returns the value of the "realized_files" field in the mutation.
func (m *AwardMutation) RealizedFiles() (r []string, exists bool) {
	v := m.realized_files
	if v == nil {
		return
	}
	return *v, true
}

// OldRealizedFiles returns the old "realized_files" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldRealizedFiles(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRealizedFiles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRealizedFiles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRealizedFiles: %w", err)
	}
	return oldValue.RealizedFiles, nil
}

// AppendRealizedFiles adds s to the "realized_files" field.
func (m *AwardMutation) AppendRealizedFiles(s []string) {
	m.appendrealized_files = append(m.appendrealized_files, s...)
}

// AppendedRealizedFiles returns the list of values that were appended to the "realized_files" field in this mutation.
func (m *AwardMutation) AppendedRealizedFiles() ([]string, bool) {
	if len(m.appendrealized_files) == 0 {
		return nil, false
	}
	return m.appendrealized_files, true
}

// ClearRealizedFiles clears the value of the "realized_files" field.
func (m *AwardMutation) ClearRealizedFiles() {
	m.realized_files = nil
	m.appendrealized_files = nil
	m.clearedFields[award.FieldRealizedFiles] = struct{}{}
}

// RealizedFilesCleared returns if the "realized_files" field was cleared in this mutation.
func (m *AwardMutation) RealizedFilesCleared() bool {
	_, ok := m.clearedFields[award.FieldRealizedFiles]
	return ok
}

// ResetRealizedFiles resets all changes to the "realized_files" field.
func (m *AwardMutation) ResetRealizedFiles() {
	m.realized_files = nil
	m.appendrealized_files = nil
	delete(m.clearedFields, award.FieldRealizedFiles)
}

// SetTargetType sets the "target_type" field.
func (m *AwardMutation) SetTargetType(at award.TargetType) {
	m.target_type = &at
}

// TargetType returns the value of the "target_type" field in the mutation.
func (m *AwardMutation) TargetType() (r award.TargetType, exists bool) {
	v := m.target_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetType returns the old "target_type" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldTargetType(ctx context.Context) (v award.TargetType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetType: %w", err)
	}
	return oldValue.TargetType, nil
}

// ResetTargetType resets all changes to the "target_type" field.
func (m *AwardMutation) ResetTargetType() {
	m.target_type = nil
}

// SetScope sets the "scope" field.
func (m *AwardMutation) SetScope(s string) {
	m.scope = &s
}

// Scope returns the value of the "scope" field in the mutation.
func (m *AwardMutation) Scope() (r string, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ResetScope resets all changes to the "scope" field.
func (m *AwardMutation) ResetScope() {
	m.scope = nil
}

// SetDimension sets the "dimension" field.
func (m *AwardMutation) SetDimension(s string) {
	m.dimension = &s
}

// Dimension returns the value of the "dimension" field in the mutation.
func (m *AwardMutation) Dimension() (r string, exists bool) {
	v := m.dimension
	if v == nil {
		return
	}
	return *v, true
}

// OldDimension returns the old "dimension" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldDimension(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDimension is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDimension requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDimension: %w", err)
	}
	return oldValue.Dimension, nil
}

// ResetDimension resets all changes to the "dimension" field.
func (m *AwardMutation) ResetDimension() {
	m.dimension = nil
}

// SetThreshold sets the "threshold" field.
func (m *AwardMutation) SetThreshold(i int32) {
	m.threshold = &i
	m.addthreshold = nil
}

// Threshold returns the value of the "threshold" field in the mutation.
func (m *AwardMutation) Threshold() (r int32, exists bool) {
	v := m.threshold
	if v == nil {
		return
	}
	return *v, true
}

// OldThreshold returns the old "threshold" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldThreshold(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreshold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreshold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreshold: %w", err)
	}
	return oldValue.Threshold, nil
}

// AddThreshold adds i to the "threshold" field.
func (m *AwardMutation) AddThreshold(i int32) {
	if m.addthreshold != nil {
		*m.addthreshold += i
	} else {
		m.addthreshold = &i
	}
}

// AddedThreshold returns the value that was added to the "threshold" field in this mutation.
func (m *AwardMutation) AddedThreshold() (r int32, exists bool) {
	v := m.addthreshold
	if v == nil {
		return
	}
	return *v, true
}

// ResetThreshold resets all changes to the "threshold" field.
func (m *AwardMutation) ResetThreshold() {
	m.threshold = nil
	m.addthreshold = nil
}

// SetSettedAt sets the "setted_at" field.
func (m *AwardMutation) SetSettedAt(i int64) {
	m.setted_at = &i
	m.addsetted_at = nil
}

// SettedAt returns the value of the "setted_at" field in the mutation.
func (m *AwardMutation) SettedAt() (r int64, exists bool) {
	v := m.setted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSettedAt returns the old "setted_at" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldSettedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettedAt: %w", err)
	}
	return oldValue.SettedAt, nil
}

// AddSettedAt adds i to the "setted_at" field.
func (m *AwardMutation) AddSettedAt(i int64) {
	if m.addsetted_at != nil {
		*m.addsetted_at += i
	} else {
		m.addsetted_at = &i
	}
}

// AddedSettedAt returns the value that was added to the "setted_at" field in this mutation.
func (m *AwardMutation) AddedSettedAt() (r int64, exists bool) {
	v := m.addsetted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetSettedAt resets all changes to the "setted_at" field.
func (m *AwardMutation) ResetSettedAt() {
	m.setted_at = nil
	m.addsetted_at = nil
}

// SetAchievedAt sets the "achieved_at" field.
func (m *AwardMutation) SetAchievedAt(i int64) {
	m.achieved_at = &i
	m.addachieved_at = nil
}

// AchievedAt returns the value of the "achieved_at" field in the mutation.
func (m *AwardMutation) AchievedAt() (r int64, exists bool) {
	v := m.achieved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAchievedAt returns the old "achieved_at" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldAchievedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAchievedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAchievedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAchievedAt: %w", err)
	}
	return oldValue.AchievedAt, nil
}

// AddAchievedAt adds i to the "achieved_at" field.
func (m *AwardMutation) AddAchievedAt(i int64) {
	if m.addachieved_at != nil {
		*m.addachieved_at += i
	} else {
		m.addachieved_at = &i
	}
}

// AddedAchievedAt returns the value that was added to the "achieved_at" field in this mutation.
func (m *AwardMutation) AddedAchievedAt() (r int64, exists bool) {
	v := m.addachieved_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearAchievedAt clears the value of the "achieved_at" field.
func (m *AwardMutation) ClearAchievedAt() {
	m.achieved_at = nil
	m.addachieved_at = nil
	m.clearedFields[award.FieldAchievedAt] = struct{}{}
}

// AchievedAtCleared returns if the "achieved_at" field was cleared in this mutation.
func (m *AwardMutation) AchievedAtCleared() bool {
	_, ok := m.clearedFields[award.FieldAchievedAt]
	return ok
}

// ResetAchievedAt resets all changes to the "achieved_at" field.
func (m *AwardMutation) ResetAchievedAt() {
	m.achieved_at = nil
	m.addachieved_at = nil
	delete(m.clearedFields, award.FieldAchievedAt)
}

// SetRealizedAt sets the "realized_at" field.
func (m *AwardMutation) SetRealizedAt(i int64) {
	m.realized_at = &i
	m.addrealized_at = nil
}

// RealizedAt returns the value of the "realized_at" field in the mutation.
func (m *AwardMutation) RealizedAt() (r int64, exists bool) {
	v := m.realized_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRealizedAt returns the old "realized_at" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldRealizedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRealizedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRealizedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRealizedAt: %w", err)
	}
	return oldValue.RealizedAt, nil
}

// AddRealizedAt adds i to the "realized_at" field.
func (m *AwardMutation) AddRealizedAt(i int64) {
	if m.addrealized_at != nil {
		*m.addrealized_at += i
	} else {
		m.addrealized_at = &i
	}
}

// AddedRealizedAt returns the value that was added to the "realized_at" field in this mutation.
func (m *AwardMutation) AddedRealizedAt() (r int64, exists bool) {
	v := m.addrealized_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearRealizedAt clears the value of the "realized_at" field.
func (m *AwardMutation) ClearRealizedAt() {
	m.realized_at = nil
	m.addrealized_at = nil
	m.clearedFields[award.FieldRealizedAt] = struct{}{}
}

// RealizedAtCleared returns if the "realized_at" field was cleared in this mutation.
func (m *AwardMutation) RealizedAtCleared() bool {
	_, ok := m.clearedFields[award.FieldRealizedAt]
	return ok
}

// ResetRealizedAt resets all changes to the "realized_at" field.
func (m *AwardMutation) ResetRealizedAt() {
	m.realized_at = nil
	m.addrealized_at = nil
	delete(m.clearedFields, award.FieldRealizedAt)
}

// Where appends a list predicates to the AwardMutation builder.
func (m *AwardMutation) Where(ps ...predicate.Award) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AwardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AwardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Award, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AwardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AwardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Award).
func (m *AwardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AwardMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.user_id != nil {
		fields = append(fields, award.FieldUserID)
	}
	if m.status != nil {
		fields = append(fields, award.FieldStatus)
	}
	if m.description != nil {
		fields = append(fields, award.FieldDescription)
	}
	if m.setted_files != nil {
		fields = append(fields, award.FieldSettedFiles)
	}
	if m.realized_files != nil {
		fields = append(fields, award.FieldRealizedFiles)
	}
	if m.target_type != nil {
		fields = append(fields, award.FieldTargetType)
	}
	if m.scope != nil {
		fields = append(fields, award.FieldScope)
	}
	if m.dimension != nil {
		fields = append(fields, award.FieldDimension)
	}
	if m.threshold != nil {
		fields = append(fields, award.FieldThreshold)
	}
	if m.setted_at != nil {
		fields = append(fields, award.FieldSettedAt)
	}
	if m.achieved_at != nil {
		fields = append(fields, award.FieldAchievedAt)
	}
	if m.realized_at != nil {
		fields = append(fields, award.FieldRealizedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AwardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case award.FieldUserID:
		return m.UserID()
	case award.FieldStatus:
		return m.Status()
	case award.FieldDescription:
		return m.Description()
	case award.FieldSettedFiles:
		return m.SettedFiles()
	case award.FieldRealizedFiles:
		return m.RealizedFiles()
	case award.FieldTargetType:
		return m.TargetType()
	case award.FieldScope:
		return m.Scope()
	case award.FieldDimension:
		return m.Dimension()
	case award.FieldThreshold:
		return m.Threshold()
	case award.FieldSettedAt:
		return m.SettedAt()
	case award.FieldAchievedAt:
		return m.AchievedAt()
	case award.FieldRealizedAt:
		return m.RealizedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AwardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case award.FieldUserID:
		return m.OldUserID(ctx)
	case award.FieldStatus:
		return m.OldStatus(ctx)
	case award.FieldDescription:
		return m.OldDescription(ctx)
	case award.FieldSettedFiles:
		return m.OldSettedFiles(ctx)
	case award.FieldRealizedFiles:
		return m.OldRealizedFiles(ctx)
	case award.FieldTargetType:
		return m.OldTargetType(ctx)
	case award.FieldScope:
		return m.OldScope(ctx)
	case award.FieldDimension:
		return m.OldDimension(ctx)
	case award.FieldThreshold:
		return m.OldThreshold(ctx)
	case award.FieldSettedAt:
		return m.OldSettedAt(ctx)
	case award.FieldAchievedAt:
		return m.OldAchievedAt(ctx)
	case award.FieldRealizedAt:
		return m.OldRealizedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Award field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AwardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case award.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case award.FieldStatus:
		v, ok := value.(award.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case award.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case award.FieldSettedFiles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettedFiles(v)
		return nil
	case award.FieldRealizedFiles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRealizedFiles(v)
		return nil
	case award.FieldTargetType:
		v, ok := value.(award.TargetType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetType(v)
		return nil
	case award.FieldScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case award.FieldDimension:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDimension(v)
		return nil
	case award.FieldThreshold:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreshold(v)
		return nil
	case award.FieldSettedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettedAt(v)
		return nil
	case award.FieldAchievedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAchievedAt(v)
		return nil
	case award.FieldRealizedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRealizedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Award field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AwardMutation) AddedFields() []string {
	var fields []string
	if m.addthreshold != nil {
		fields = append(fields, award.FieldThreshold)
	}
	if m.addsetted_at != nil {
		fields = append(fields, award.FieldSettedAt)
	}
	if m.addachieved_at != nil {
		fields = append(fields, award.FieldAchievedAt)
	}
	if m.addrealized_at != nil {
		fields = append(fields, award.FieldRealizedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AwardMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case award.FieldThreshold:
		return m.AddedThreshold()
	case award.FieldSettedAt:
		return m.AddedSettedAt()
	case award.FieldAchievedAt:
		return m.AddedAchievedAt()
	case award.FieldRealizedAt:
		return m.AddedRealizedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AwardMutation) AddField(name string, value ent.Value) error {
	switch name {
	case award.FieldThreshold:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThreshold(v)
		return nil
	case award.FieldSettedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSettedAt(v)
		return nil
	case award.FieldAchievedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAchievedAt(v)
		return nil
	case award.FieldRealizedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRealizedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Award numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AwardMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(award.FieldSettedFiles) {
		fields = append(fields, award.FieldSettedFiles)
	}
	if m.FieldCleared(award.FieldRealizedFiles) {
		fields = append(fields, award.FieldRealizedFiles)
	}
	if m.FieldCleared(award.FieldAchievedAt) {
		fields = append(fields, award.FieldAchievedAt)
	}
	if m.FieldCleared(award.FieldRealizedAt) {
		fields = append(fields, award.FieldRealizedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AwardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AwardMutation) ClearField(name string) error {
	switch name {
	case award.FieldSettedFiles:
		m.ClearSettedFiles()
		return nil
	case award.FieldRealizedFiles:
		m.ClearRealizedFiles()
		return nil
	case award.FieldAchievedAt:
		m.ClearAchievedAt()
		return nil
	case award.FieldRealizedAt:
		m.ClearRealizedAt()
		return nil
	}
	return fmt.Errorf("unknown Award nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AwardMutation) ResetField(name string) error {
	switch name {
	case award.FieldUserID:
		m.ResetUserID()
		return nil
	case award.FieldStatus:
		m.ResetStatus()
		return nil
	case award.FieldDescription:
		m.ResetDescription()
		return nil
	case award.FieldSettedFiles:
		m.ResetSettedFiles()
		return nil
	case award.FieldRealizedFiles:
		m.ResetRealizedFiles()
		return nil
	case award.FieldTargetType:
		m.ResetTargetType()
		return nil
	case award.FieldScope:
		m.ResetScope()
		return nil
	case award.FieldDimension:
		m.ResetDimension()
		return nil
	case award.FieldThreshold:
		m.ResetThreshold()
		return nil
	case award.FieldSettedAt:
		m.ResetSettedAt()
		return nil
	case award.FieldAchievedAt:
		m.ResetAchievedAt()
		return nil
	case award.FieldRealizedAt:
		m.ResetRealizedAt()
		return nil
	}
	return fmt.Errorf("unknown Award field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AwardMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AwardMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AwardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AwardMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AwardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AwardMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AwardMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Award unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AwardMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Award edge %s", name)
}

// PortraitMutation represents an operation that mutates the Portrait nodes in the graph.
type PortraitMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	user_id       *string
	dimension     *portrait.Dimension
	value         *map[string]interface{}
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Portrait, error)
	predicates    []predicate.Portrait
}

var _ ent.Mutation = (*PortraitMutation)(nil)

// portraitOption allows management of the mutation configuration using functional options.
type portraitOption func(*PortraitMutation)

// newPortraitMutation creates new mutation for the Portrait entity.
func newPortraitMutation(c config, op Op, opts ...portraitOption) *PortraitMutation {
	m := &PortraitMutation{
		config:        c,
		op:            op,
		typ:           TypePortrait,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPortraitID sets the ID field of the mutation.
func withPortraitID(id uint64) portraitOption {
	return func(m *PortraitMutation) {
		var (
			err   error
			once  sync.Once
			value *Portrait
		)
		m.oldValue = func(ctx context.Context) (*Portrait, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Portrait.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPortrait sets the old Portrait of the mutation.
func withPortrait(node *Portrait) portraitOption {
	return func(m *PortraitMutation) {
		m.oldValue = func(context.Context) (*Portrait, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PortraitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PortraitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Portrait entities.
func (m *PortraitMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PortraitMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PortraitMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Portrait.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *PortraitMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PortraitMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Portrait entity.
// If the Portrait object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortraitMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PortraitMutation) ResetUserID() {
	m.user_id = nil
}

// SetDimension sets the "dimension" field.
func (m *PortraitMutation) SetDimension(po portrait.Dimension) {
	m.dimension = &po
}

// Dimension returns the value of the "dimension" field in the mutation.
func (m *PortraitMutation) Dimension() (r portrait.Dimension, exists bool) {
	v := m.dimension
	if v == nil {
		return
	}
	return *v, true
}

// OldDimension returns the old "dimension" field's value of the Portrait entity.
// If the Portrait object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortraitMutation) OldDimension(ctx context.Context) (v portrait.Dimension, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDimension is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDimension requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDimension: %w", err)
	}
	return oldValue.Dimension, nil
}

// ResetDimension resets all changes to the "dimension" field.
func (m *PortraitMutation) ResetDimension() {
	m.dimension = nil
}

// SetValue sets the "value" field.
func (m *PortraitMutation) SetValue(value map[string]interface{}) {
	m.value = &value
}

// Value returns the value of the "value" field in the mutation.
func (m *PortraitMutation) Value() (r map[string]interface{}, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Portrait entity.
// If the Portrait object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortraitMutation) OldValue(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *PortraitMutation) ResetValue() {
	m.value = nil
}

// Where appends a list predicates to the PortraitMutation builder.
func (m *PortraitMutation) Where(ps ...predicate.Portrait) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PortraitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PortraitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Portrait, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PortraitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PortraitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Portrait).
func (m *PortraitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PortraitMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user_id != nil {
		fields = append(fields, portrait.FieldUserID)
	}
	if m.dimension != nil {
		fields = append(fields, portrait.FieldDimension)
	}
	if m.value != nil {
		fields = append(fields, portrait.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PortraitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case portrait.FieldUserID:
		return m.UserID()
	case portrait.FieldDimension:
		return m.Dimension()
	case portrait.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PortraitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case portrait.FieldUserID:
		return m.OldUserID(ctx)
	case portrait.FieldDimension:
		return m.OldDimension(ctx)
	case portrait.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Portrait field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PortraitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case portrait.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case portrait.FieldDimension:
		v, ok := value.(portrait.Dimension)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDimension(v)
		return nil
	case portrait.FieldValue:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Portrait field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PortraitMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PortraitMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PortraitMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Portrait numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PortraitMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PortraitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PortraitMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Portrait nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PortraitMutation) ResetField(name string) error {
	switch name {
	case portrait.FieldUserID:
		m.ResetUserID()
		return nil
	case portrait.FieldDimension:
		m.ResetDimension()
		return nil
	case portrait.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Portrait field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PortraitMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PortraitMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PortraitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PortraitMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PortraitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PortraitMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PortraitMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Portrait unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PortraitMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Portrait edge %s", name)
}

// ShowMutation represents an operation that mutates the Show nodes in the graph.
type ShowMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint64
	_type                *string
	poster               *string
	content              *string
	media_files          *[]string
	appendmedia_files    []string
	created_at           *int64
	addcreated_at        *int64
	clearedFields        map[string]struct{}
	show_reserves        map[uint64]struct{}
	removedshow_reserves map[uint64]struct{}
	clearedshow_reserves bool
	done                 bool
	oldValue             func(context.Context) (*Show, error)
	predicates           []predicate.Show
}

var _ ent.Mutation = (*ShowMutation)(nil)

// showOption allows management of the mutation configuration using functional options.
type showOption func(*ShowMutation)

// newShowMutation creates new mutation for the Show entity.
func newShowMutation(c config, op Op, opts ...showOption) *ShowMutation {
	m := &ShowMutation{
		config:        c,
		op:            op,
		typ:           TypeShow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShowID sets the ID field of the mutation.
func withShowID(id uint64) showOption {
	return func(m *ShowMutation) {
		var (
			err   error
			once  sync.Once
			value *Show
		)
		m.oldValue = func(ctx context.Context) (*Show, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Show.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShow sets the old Show of the mutation.
func withShow(node *Show) showOption {
	return func(m *ShowMutation) {
		m.oldValue = func(context.Context) (*Show, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Show entities.
func (m *ShowMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShowMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShowMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Show.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *ShowMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ShowMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Show entity.
// If the Show object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShowMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ShowMutation) ResetType() {
	m._type = nil
}

// SetPoster sets the "poster" field.
func (m *ShowMutation) SetPoster(s string) {
	m.poster = &s
}

// Poster returns the value of the "poster" field in the mutation.
func (m *ShowMutation) Poster() (r string, exists bool) {
	v := m.poster
	if v == nil {
		return
	}
	return *v, true
}

// OldPoster returns the old "poster" field's value of the Show entity.
// If the Show object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShowMutation) OldPoster(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoster is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoster requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoster: %w", err)
	}
	return oldValue.Poster, nil
}

// ClearPoster clears the value of the "poster" field.
func (m *ShowMutation) ClearPoster() {
	m.poster = nil
	m.clearedFields[show.FieldPoster] = struct{}{}
}

// PosterCleared returns if the "poster" field was cleared in this mutation.
func (m *ShowMutation) PosterCleared() bool {
	_, ok := m.clearedFields[show.FieldPoster]
	return ok
}

// ResetPoster resets all changes to the "poster" field.
func (m *ShowMutation) ResetPoster() {
	m.poster = nil
	delete(m.clearedFields, show.FieldPoster)
}

// SetContent sets the "content" field.
func (m *ShowMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ShowMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Show entity.
// If the Show object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShowMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *ShowMutation) ResetContent() {
	m.content = nil
}

// SetMediaFiles sets the "media_files" field.
func (m *ShowMutation) SetMediaFiles(s []string) {
	m.media_files = &s
	m.appendmedia_files = nil
}

// MediaFiles returns the value of the "media_files" field in the mutation.
func (m *ShowMutation) MediaFiles() (r []string, exists bool) {
	v := m.media_files
	if v == nil {
		return
	}
	return *v, true
}

// OldMediaFiles returns the old "media_files" field's value of the Show entity.
// If the Show object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShowMutation) OldMediaFiles(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMediaFiles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMediaFiles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMediaFiles: %w", err)
	}
	return oldValue.MediaFiles, nil
}

// AppendMediaFiles adds s to the "media_files" field.
func (m *ShowMutation) AppendMediaFiles(s []string) {
	m.appendmedia_files = append(m.appendmedia_files, s...)
}

// AppendedMediaFiles returns the list of values that were appended to the "media_files" field in this mutation.
func (m *ShowMutation) AppendedMediaFiles() ([]string, bool) {
	if len(m.appendmedia_files) == 0 {
		return nil, false
	}
	return m.appendmedia_files, true
}

// ClearMediaFiles clears the value of the "media_files" field.
func (m *ShowMutation) ClearMediaFiles() {
	m.media_files = nil
	m.appendmedia_files = nil
	m.clearedFields[show.FieldMediaFiles] = struct{}{}
}

// MediaFilesCleared returns if the "media_files" field was cleared in this mutation.
func (m *ShowMutation) MediaFilesCleared() bool {
	_, ok := m.clearedFields[show.FieldMediaFiles]
	return ok
}

// ResetMediaFiles resets all changes to the "media_files" field.
func (m *ShowMutation) ResetMediaFiles() {
	m.media_files = nil
	m.appendmedia_files = nil
	delete(m.clearedFields, show.FieldMediaFiles)
}

// SetCreatedAt sets the "created_at" field.
func (m *ShowMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ShowMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Show entity.
// If the Show object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShowMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *ShowMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *ShowMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ShowMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// AddShowReserfIDs adds the "show_reserves" edge to the ShowReserve entity by ids.
func (m *ShowMutation) AddShowReserfIDs(ids ...uint64) {
	if m.show_reserves == nil {
		m.show_reserves = make(map[uint64]struct{})
	}
	for i := range ids {
		m.show_reserves[ids[i]] = struct{}{}
	}
}

// ClearShowReserves clears the "show_reserves" edge to the ShowReserve entity.
func (m *ShowMutation) ClearShowReserves() {
	m.clearedshow_reserves = true
}

// ShowReservesCleared reports if the "show_reserves" edge to the ShowReserve entity was cleared.
func (m *ShowMutation) ShowReservesCleared() bool {
	return m.clearedshow_reserves
}

// RemoveShowReserfIDs removes the "show_reserves" edge to the ShowReserve entity by IDs.
func (m *ShowMutation) RemoveShowReserfIDs(ids ...uint64) {
	if m.removedshow_reserves == nil {
		m.removedshow_reserves = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.show_reserves, ids[i])
		m.removedshow_reserves[ids[i]] = struct{}{}
	}
}

// RemovedShowReserves returns the removed IDs of the "show_reserves" edge to the ShowReserve entity.
func (m *ShowMutation) RemovedShowReservesIDs() (ids []uint64) {
	for id := range m.removedshow_reserves {
		ids = append(ids, id)
	}
	return
}

// ShowReservesIDs returns the "show_reserves" edge IDs in the mutation.
func (m *ShowMutation) ShowReservesIDs() (ids []uint64) {
	for id := range m.show_reserves {
		ids = append(ids, id)
	}
	return
}

// ResetShowReserves resets all changes to the "show_reserves" edge.
func (m *ShowMutation) ResetShowReserves() {
	m.show_reserves = nil
	m.clearedshow_reserves = false
	m.removedshow_reserves = nil
}

// Where appends a list predicates to the ShowMutation builder.
func (m *ShowMutation) Where(ps ...predicate.Show) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Show, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Show).
func (m *ShowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShowMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._type != nil {
		fields = append(fields, show.FieldType)
	}
	if m.poster != nil {
		fields = append(fields, show.FieldPoster)
	}
	if m.content != nil {
		fields = append(fields, show.FieldContent)
	}
	if m.media_files != nil {
		fields = append(fields, show.FieldMediaFiles)
	}
	if m.created_at != nil {
		fields = append(fields, show.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case show.FieldType:
		return m.GetType()
	case show.FieldPoster:
		return m.Poster()
	case show.FieldContent:
		return m.Content()
	case show.FieldMediaFiles:
		return m.MediaFiles()
	case show.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case show.FieldType:
		return m.OldType(ctx)
	case show.FieldPoster:
		return m.OldPoster(ctx)
	case show.FieldContent:
		return m.OldContent(ctx)
	case show.FieldMediaFiles:
		return m.OldMediaFiles(ctx)
	case show.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Show field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case show.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case show.FieldPoster:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoster(v)
		return nil
	case show.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case show.FieldMediaFiles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMediaFiles(v)
		return nil
	case show.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Show field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShowMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, show.FieldCreatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShowMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case show.FieldCreatedAt:
		return m.AddedCreatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShowMutation) AddField(name string, value ent.Value) error {
	switch name {
	case show.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Show numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(show.FieldPoster) {
		fields = append(fields, show.FieldPoster)
	}
	if m.FieldCleared(show.FieldMediaFiles) {
		fields = append(fields, show.FieldMediaFiles)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShowMutation) ClearField(name string) error {
	switch name {
	case show.FieldPoster:
		m.ClearPoster()
		return nil
	case show.FieldMediaFiles:
		m.ClearMediaFiles()
		return nil
	}
	return fmt.Errorf("unknown Show nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShowMutation) ResetField(name string) error {
	switch name {
	case show.FieldType:
		m.ResetType()
		return nil
	case show.FieldPoster:
		m.ResetPoster()
		return nil
	case show.FieldContent:
		m.ResetContent()
		return nil
	case show.FieldMediaFiles:
		m.ResetMediaFiles()
		return nil
	case show.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Show field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShowMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.show_reserves != nil {
		edges = append(edges, show.EdgeShowReserves)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case show.EdgeShowReserves:
		ids := make([]ent.Value, 0, len(m.show_reserves))
		for id := range m.show_reserves {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedshow_reserves != nil {
		edges = append(edges, show.EdgeShowReserves)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShowMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case show.EdgeShowReserves:
		ids := make([]ent.Value, 0, len(m.removedshow_reserves))
		for id := range m.removedshow_reserves {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedshow_reserves {
		edges = append(edges, show.EdgeShowReserves)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShowMutation) EdgeCleared(name string) bool {
	switch name {
	case show.EdgeShowReserves:
		return m.clearedshow_reserves
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShowMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Show unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShowMutation) ResetEdge(name string) error {
	switch name {
	case show.EdgeShowReserves:
		m.ResetShowReserves()
		return nil
	}
	return fmt.Errorf("unknown Show edge %s", name)
}

// ShowReserveMutation represents an operation that mutates the ShowReserve nodes in the graph.
type ShowReserveMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	user_id        *string
	status         *showreserve.Status
	memories       *[]string
	appendmemories []string
	created_at     *int64
	addcreated_at  *int64
	clearedFields  map[string]struct{}
	show           *uint64
	clearedshow    bool
	done           bool
	oldValue       func(context.Context) (*ShowReserve, error)
	predicates     []predicate.ShowReserve
}

var _ ent.Mutation = (*ShowReserveMutation)(nil)

// showreserveOption allows management of the mutation configuration using functional options.
type showreserveOption func(*ShowReserveMutation)

// newShowReserveMutation creates new mutation for the ShowReserve entity.
func newShowReserveMutation(c config, op Op, opts ...showreserveOption) *ShowReserveMutation {
	m := &ShowReserveMutation{
		config:        c,
		op:            op,
		typ:           TypeShowReserve,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShowReserveID sets the ID field of the mutation.
func withShowReserveID(id uint64) showreserveOption {
	return func(m *ShowReserveMutation) {
		var (
			err   error
			once  sync.Once
			value *ShowReserve
		)
		m.oldValue = func(ctx context.Context) (*ShowReserve, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShowReserve.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShowReserve sets the old ShowReserve of the mutation.
func withShowReserve(node *ShowReserve) showreserveOption {
	return func(m *ShowReserveMutation) {
		m.oldValue = func(context.Context) (*ShowReserve, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShowReserveMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShowReserveMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ShowReserve entities.
func (m *ShowReserveMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShowReserveMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShowReserveMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShowReserve.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *ShowReserveMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ShowReserveMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ShowReserve entity.
// If the ShowReserve object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShowReserveMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ShowReserveMutation) ResetUserID() {
	m.user_id = nil
}

// SetStatus sets the "status" field.
func (m *ShowReserveMutation) SetStatus(s showreserve.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ShowReserveMutation) Status() (r showreserve.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ShowReserve entity.
// If the ShowReserve object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShowReserveMutation) OldStatus(ctx context.Context) (v showreserve.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ShowReserveMutation) ResetStatus() {
	m.status = nil
}

// SetMemories sets the "memories" field.
func (m *ShowReserveMutation) SetMemories(s []string) {
	m.memories = &s
	m.appendmemories = nil
}

// Memories returns the value of the "memories" field in the mutation.
func (m *ShowReserveMutation) Memories() (r []string, exists bool) {
	v := m.memories
	if v == nil {
		return
	}
	return *v, true
}

// OldMemories returns the old "memories" field's value of the ShowReserve entity.
// If the ShowReserve object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShowReserveMutation) OldMemories(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemories is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemories requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemories: %w", err)
	}
	return oldValue.Memories, nil
}

// AppendMemories adds s to the "memories" field.
func (m *ShowReserveMutation) AppendMemories(s []string) {
	m.appendmemories = append(m.appendmemories, s...)
}

// AppendedMemories returns the list of values that were appended to the "memories" field in this mutation.
func (m *ShowReserveMutation) AppendedMemories() ([]string, bool) {
	if len(m.appendmemories) == 0 {
		return nil, false
	}
	return m.appendmemories, true
}

// ClearMemories clears the value of the "memories" field.
func (m *ShowReserveMutation) ClearMemories() {
	m.memories = nil
	m.appendmemories = nil
	m.clearedFields[showreserve.FieldMemories] = struct{}{}
}

// MemoriesCleared returns if the "memories" field was cleared in this mutation.
func (m *ShowReserveMutation) MemoriesCleared() bool {
	_, ok := m.clearedFields[showreserve.FieldMemories]
	return ok
}

// ResetMemories resets all changes to the "memories" field.
func (m *ShowReserveMutation) ResetMemories() {
	m.memories = nil
	m.appendmemories = nil
	delete(m.clearedFields, showreserve.FieldMemories)
}

// SetCreatedAt sets the "created_at" field.
func (m *ShowReserveMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ShowReserveMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ShowReserve entity.
// If the ShowReserve object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShowReserveMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *ShowReserveMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *ShowReserveMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ShowReserveMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetRefShowID sets the "ref_show_id" field.
func (m *ShowReserveMutation) SetRefShowID(u uint64) {
	m.show = &u
}

// RefShowID returns the value of the "ref_show_id" field in the mutation.
func (m *ShowReserveMutation) RefShowID() (r uint64, exists bool) {
	v := m.show
	if v == nil {
		return
	}
	return *v, true
}

// OldRefShowID returns the old "ref_show_id" field's value of the ShowReserve entity.
// If the ShowReserve object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShowReserveMutation) OldRefShowID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefShowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefShowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefShowID: %w", err)
	}
	return oldValue.RefShowID, nil
}

// ClearRefShowID clears the value of the "ref_show_id" field.
func (m *ShowReserveMutation) ClearRefShowID() {
	m.show = nil
	m.clearedFields[showreserve.FieldRefShowID] = struct{}{}
}

// RefShowIDCleared returns if the "ref_show_id" field was cleared in this mutation.
func (m *ShowReserveMutation) RefShowIDCleared() bool {
	_, ok := m.clearedFields[showreserve.FieldRefShowID]
	return ok
}

// ResetRefShowID resets all changes to the "ref_show_id" field.
func (m *ShowReserveMutation) ResetRefShowID() {
	m.show = nil
	delete(m.clearedFields, showreserve.FieldRefShowID)
}

// SetShowID sets the "show" edge to the Show entity by id.
func (m *ShowReserveMutation) SetShowID(id uint64) {
	m.show = &id
}

// ClearShow clears the "show" edge to the Show entity.
func (m *ShowReserveMutation) ClearShow() {
	m.clearedshow = true
	m.clearedFields[showreserve.FieldRefShowID] = struct{}{}
}

// ShowCleared reports if the "show" edge to the Show entity was cleared.
func (m *ShowReserveMutation) ShowCleared() bool {
	return m.RefShowIDCleared() || m.clearedshow
}

// ShowID returns the "show" edge ID in the mutation.
func (m *ShowReserveMutation) ShowID() (id uint64, exists bool) {
	if m.show != nil {
		return *m.show, true
	}
	return
}

// ShowIDs returns the "show" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShowID instead. It exists only for internal usage by the builders.
func (m *ShowReserveMutation) ShowIDs() (ids []uint64) {
	if id := m.show; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShow resets all changes to the "show" edge.
func (m *ShowReserveMutation) ResetShow() {
	m.show = nil
	m.clearedshow = false
}

// Where appends a list predicates to the ShowReserveMutation builder.
func (m *ShowReserveMutation) Where(ps ...predicate.ShowReserve) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShowReserveMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShowReserveMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShowReserve, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShowReserveMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShowReserveMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShowReserve).
func (m *ShowReserveMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShowReserveMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user_id != nil {
		fields = append(fields, showreserve.FieldUserID)
	}
	if m.status != nil {
		fields = append(fields, showreserve.FieldStatus)
	}
	if m.memories != nil {
		fields = append(fields, showreserve.FieldMemories)
	}
	if m.created_at != nil {
		fields = append(fields, showreserve.FieldCreatedAt)
	}
	if m.show != nil {
		fields = append(fields, showreserve.FieldRefShowID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShowReserveMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case showreserve.FieldUserID:
		return m.UserID()
	case showreserve.FieldStatus:
		return m.Status()
	case showreserve.FieldMemories:
		return m.Memories()
	case showreserve.FieldCreatedAt:
		return m.CreatedAt()
	case showreserve.FieldRefShowID:
		return m.RefShowID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShowReserveMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case showreserve.FieldUserID:
		return m.OldUserID(ctx)
	case showreserve.FieldStatus:
		return m.OldStatus(ctx)
	case showreserve.FieldMemories:
		return m.OldMemories(ctx)
	case showreserve.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case showreserve.FieldRefShowID:
		return m.OldRefShowID(ctx)
	}
	return nil, fmt.Errorf("unknown ShowReserve field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShowReserveMutation) SetField(name string, value ent.Value) error {
	switch name {
	case showreserve.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case showreserve.FieldStatus:
		v, ok := value.(showreserve.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case showreserve.FieldMemories:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemories(v)
		return nil
	case showreserve.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case showreserve.FieldRefShowID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefShowID(v)
		return nil
	}
	return fmt.Errorf("unknown ShowReserve field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShowReserveMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, showreserve.FieldCreatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShowReserveMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case showreserve.FieldCreatedAt:
		return m.AddedCreatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShowReserveMutation) AddField(name string, value ent.Value) error {
	switch name {
	case showreserve.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ShowReserve numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShowReserveMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(showreserve.FieldMemories) {
		fields = append(fields, showreserve.FieldMemories)
	}
	if m.FieldCleared(showreserve.FieldRefShowID) {
		fields = append(fields, showreserve.FieldRefShowID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShowReserveMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShowReserveMutation) ClearField(name string) error {
	switch name {
	case showreserve.FieldMemories:
		m.ClearMemories()
		return nil
	case showreserve.FieldRefShowID:
		m.ClearRefShowID()
		return nil
	}
	return fmt.Errorf("unknown ShowReserve nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShowReserveMutation) ResetField(name string) error {
	switch name {
	case showreserve.FieldUserID:
		m.ResetUserID()
		return nil
	case showreserve.FieldStatus:
		m.ResetStatus()
		return nil
	case showreserve.FieldMemories:
		m.ResetMemories()
		return nil
	case showreserve.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case showreserve.FieldRefShowID:
		m.ResetRefShowID()
		return nil
	}
	return fmt.Errorf("unknown ShowReserve field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShowReserveMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.show != nil {
		edges = append(edges, showreserve.EdgeShow)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShowReserveMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case showreserve.EdgeShow:
		if id := m.show; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShowReserveMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShowReserveMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShowReserveMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedshow {
		edges = append(edges, showreserve.EdgeShow)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShowReserveMutation) EdgeCleared(name string) bool {
	switch name {
	case showreserve.EdgeShow:
		return m.clearedshow
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShowReserveMutation) ClearEdge(name string) error {
	switch name {
	case showreserve.EdgeShow:
		m.ClearShow()
		return nil
	}
	return fmt.Errorf("unknown ShowReserve unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShowReserveMutation) ResetEdge(name string) error {
	switch name {
	case showreserve.EdgeShow:
		m.ResetShow()
		return nil
	}
	return fmt.Errorf("unknown ShowReserve edge %s", name)
}

// StepMutation represents an operation that mutates the Step nodes in the graph.
type StepMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	title           *string
	description     *string
	is_challenge    *bool
	teacher_comment *map[string]interface{}
	parent_comment  *map[string]interface{}
	friend_comment  *map[string]interface{}
	_type           *step.Type
	object_name     *string
	created_at      *int64
	addcreated_at   *int64
	clearedFields   map[string]struct{}
	target          *uint64
	clearedtarget   bool
	parent          *uint64
	clearedparent   bool
	children        map[uint64]struct{}
	removedchildren map[uint64]struct{}
	clearedchildren bool
	done            bool
	oldValue        func(context.Context) (*Step, error)
	predicates      []predicate.Step
}

var _ ent.Mutation = (*StepMutation)(nil)

// stepOption allows management of the mutation configuration using functional options.
type stepOption func(*StepMutation)

// newStepMutation creates new mutation for the Step entity.
func newStepMutation(c config, op Op, opts ...stepOption) *StepMutation {
	m := &StepMutation{
		config:        c,
		op:            op,
		typ:           TypeStep,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStepID sets the ID field of the mutation.
func withStepID(id uint64) stepOption {
	return func(m *StepMutation) {
		var (
			err   error
			once  sync.Once
			value *Step
		)
		m.oldValue = func(ctx context.Context) (*Step, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Step.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStep sets the old Step of the mutation.
func withStep(node *Step) stepOption {
	return func(m *StepMutation) {
		m.oldValue = func(context.Context) (*Step, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StepMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StepMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Step entities.
func (m *StepMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StepMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StepMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Step.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *StepMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *StepMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Step entity.
// If the Step object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *StepMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[step.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *StepMutation) TitleCleared() bool {
	_, ok := m.clearedFields[step.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *StepMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, step.FieldTitle)
}

// SetDescription sets the "description" field.
func (m *StepMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *StepMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Step entity.
// If the Step object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *StepMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[step.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *StepMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[step.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *StepMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, step.FieldDescription)
}

// SetIsChallenge sets the "is_challenge" field.
func (m *StepMutation) SetIsChallenge(b bool) {
	m.is_challenge = &b
}

// IsChallenge returns the value of the "is_challenge" field in the mutation.
func (m *StepMutation) IsChallenge() (r bool, exists bool) {
	v := m.is_challenge
	if v == nil {
		return
	}
	return *v, true
}

// OldIsChallenge returns the old "is_challenge" field's value of the Step entity.
// If the Step object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepMutation) OldIsChallenge(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsChallenge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsChallenge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsChallenge: %w", err)
	}
	return oldValue.IsChallenge, nil
}

// ResetIsChallenge resets all changes to the "is_challenge" field.
func (m *StepMutation) ResetIsChallenge() {
	m.is_challenge = nil
}

// SetTeacherComment sets the "teacher_comment" field.
func (m *StepMutation) SetTeacherComment(value map[string]interface{}) {
	m.teacher_comment = &value
}

// TeacherComment returns the value of the "teacher_comment" field in the mutation.
func (m *StepMutation) TeacherComment() (r map[string]interface{}, exists bool) {
	v := m.teacher_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldTeacherComment returns the old "teacher_comment" field's value of the Step entity.
// If the Step object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepMutation) OldTeacherComment(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeacherComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeacherComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeacherComment: %w", err)
	}
	return oldValue.TeacherComment, nil
}

// ClearTeacherComment clears the value of the "teacher_comment" field.
func (m *StepMutation) ClearTeacherComment() {
	m.teacher_comment = nil
	m.clearedFields[step.FieldTeacherComment] = struct{}{}
}

// TeacherCommentCleared returns if the "teacher_comment" field was cleared in this mutation.
func (m *StepMutation) TeacherCommentCleared() bool {
	_, ok := m.clearedFields[step.FieldTeacherComment]
	return ok
}

// ResetTeacherComment resets all changes to the "teacher_comment" field.
func (m *StepMutation) ResetTeacherComment() {
	m.teacher_comment = nil
	delete(m.clearedFields, step.FieldTeacherComment)
}

// SetParentComment sets the "parent_comment" field.
func (m *StepMutation) SetParentComment(value map[string]interface{}) {
	m.parent_comment = &value
}

// ParentComment returns the value of the "parent_comment" field in the mutation.
func (m *StepMutation) ParentComment() (r map[string]interface{}, exists bool) {
	v := m.parent_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldParentComment returns the old "parent_comment" field's value of the Step entity.
// If the Step object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepMutation) OldParentComment(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentComment: %w", err)
	}
	return oldValue.ParentComment, nil
}

// ClearParentComment clears the value of the "parent_comment" field.
func (m *StepMutation) ClearParentComment() {
	m.parent_comment = nil
	m.clearedFields[step.FieldParentComment] = struct{}{}
}

// ParentCommentCleared returns if the "parent_comment" field was cleared in this mutation.
func (m *StepMutation) ParentCommentCleared() bool {
	_, ok := m.clearedFields[step.FieldParentComment]
	return ok
}

// ResetParentComment resets all changes to the "parent_comment" field.
func (m *StepMutation) ResetParentComment() {
	m.parent_comment = nil
	delete(m.clearedFields, step.FieldParentComment)
}

// SetFriendComment sets the "friend_comment" field.
func (m *StepMutation) SetFriendComment(value map[string]interface{}) {
	m.friend_comment = &value
}

// FriendComment returns the value of the "friend_comment" field in the mutation.
func (m *StepMutation) FriendComment() (r map[string]interface{}, exists bool) {
	v := m.friend_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldFriendComment returns the old "friend_comment" field's value of the Step entity.
// If the Step object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepMutation) OldFriendComment(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFriendComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFriendComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFriendComment: %w", err)
	}
	return oldValue.FriendComment, nil
}

// ClearFriendComment clears the value of the "friend_comment" field.
func (m *StepMutation) ClearFriendComment() {
	m.friend_comment = nil
	m.clearedFields[step.FieldFriendComment] = struct{}{}
}

// FriendCommentCleared returns if the "friend_comment" field was cleared in this mutation.
func (m *StepMutation) FriendCommentCleared() bool {
	_, ok := m.clearedFields[step.FieldFriendComment]
	return ok
}

// ResetFriendComment resets all changes to the "friend_comment" field.
func (m *StepMutation) ResetFriendComment() {
	m.friend_comment = nil
	delete(m.clearedFields, step.FieldFriendComment)
}

// SetType sets the "type" field.
func (m *StepMutation) SetType(s step.Type) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *StepMutation) GetType() (r step.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Step entity.
// If the Step object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepMutation) OldType(ctx context.Context) (v step.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *StepMutation) ResetType() {
	m._type = nil
}

// SetObjectName sets the "object_name" field.
func (m *StepMutation) SetObjectName(s string) {
	m.object_name = &s
}

// ObjectName returns the value of the "object_name" field in the mutation.
func (m *StepMutation) ObjectName() (r string, exists bool) {
	v := m.object_name
	if v == nil {
		return
	}
	return *v, true
}

// OldObjectName returns the old "object_name" field's value of the Step entity.
// If the Step object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepMutation) OldObjectName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldObjectName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldObjectName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObjectName: %w", err)
	}
	return oldValue.ObjectName, nil
}

// ClearObjectName clears the value of the "object_name" field.
func (m *StepMutation) ClearObjectName() {
	m.object_name = nil
	m.clearedFields[step.FieldObjectName] = struct{}{}
}

// ObjectNameCleared returns if the "object_name" field was cleared in this mutation.
func (m *StepMutation) ObjectNameCleared() bool {
	_, ok := m.clearedFields[step.FieldObjectName]
	return ok
}

// ResetObjectName resets all changes to the "object_name" field.
func (m *StepMutation) ResetObjectName() {
	m.object_name = nil
	delete(m.clearedFields, step.FieldObjectName)
}

// SetCreatedAt sets the "created_at" field.
func (m *StepMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StepMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Step entity.
// If the Step object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *StepMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *StepMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StepMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetRefTargetID sets the "ref_target_id" field.
func (m *StepMutation) SetRefTargetID(u uint64) {
	m.target = &u
}

// RefTargetID returns the value of the "ref_target_id" field in the mutation.
func (m *StepMutation) RefTargetID() (r uint64, exists bool) {
	v := m.target
	if v == nil {
		return
	}
	return *v, true
}

// OldRefTargetID returns the old "ref_target_id" field's value of the Step entity.
// If the Step object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepMutation) OldRefTargetID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefTargetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefTargetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefTargetID: %w", err)
	}
	return oldValue.RefTargetID, nil
}

// ClearRefTargetID clears the value of the "ref_target_id" field.
func (m *StepMutation) ClearRefTargetID() {
	m.target = nil
	m.clearedFields[step.FieldRefTargetID] = struct{}{}
}

// RefTargetIDCleared returns if the "ref_target_id" field was cleared in this mutation.
func (m *StepMutation) RefTargetIDCleared() bool {
	_, ok := m.clearedFields[step.FieldRefTargetID]
	return ok
}

// ResetRefTargetID resets all changes to the "ref_target_id" field.
func (m *StepMutation) ResetRefTargetID() {
	m.target = nil
	delete(m.clearedFields, step.FieldRefTargetID)
}

// SetParentID sets the "parent_id" field.
func (m *StepMutation) SetParentID(u uint64) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *StepMutation) ParentID() (r uint64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Step entity.
// If the Step object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepMutation) OldParentID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *StepMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[step.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *StepMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[step.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *StepMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, step.FieldParentID)
}

// SetTargetID sets the "target" edge to the Target entity by id.
func (m *StepMutation) SetTargetID(id uint64) {
	m.target = &id
}

// ClearTarget clears the "target" edge to the Target entity.
func (m *StepMutation) ClearTarget() {
	m.clearedtarget = true
	m.clearedFields[step.FieldRefTargetID] = struct{}{}
}

// TargetCleared reports if the "target" edge to the Target entity was cleared.
func (m *StepMutation) TargetCleared() bool {
	return m.RefTargetIDCleared() || m.clearedtarget
}

// TargetID returns the "target" edge ID in the mutation.
func (m *StepMutation) TargetID() (id uint64, exists bool) {
	if m.target != nil {
		return *m.target, true
	}
	return
}

// TargetIDs returns the "target" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TargetID instead. It exists only for internal usage by the builders.
func (m *StepMutation) TargetIDs() (ids []uint64) {
	if id := m.target; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTarget resets all changes to the "target" edge.
func (m *StepMutation) ResetTarget() {
	m.target = nil
	m.clearedtarget = false
}

// ClearParent clears the "parent" edge to the Step entity.
func (m *StepMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[step.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Step entity was cleared.
func (m *StepMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *StepMutation) ParentIDs() (ids []uint64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *StepMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Step entity by ids.
func (m *StepMutation) AddChildIDs(ids ...uint64) {
	if m.children == nil {
		m.children = make(map[uint64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Step entity.
func (m *StepMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Step entity was cleared.
func (m *StepMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Step entity by IDs.
func (m *StepMutation) RemoveChildIDs(ids ...uint64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Step entity.
func (m *StepMutation) RemovedChildrenIDs() (ids []uint64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *StepMutation) ChildrenIDs() (ids []uint64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *StepMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the StepMutation builder.
func (m *StepMutation) Where(ps ...predicate.Step) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StepMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StepMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Step, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StepMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StepMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Step).
func (m *StepMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StepMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.title != nil {
		fields = append(fields, step.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, step.FieldDescription)
	}
	if m.is_challenge != nil {
		fields = append(fields, step.FieldIsChallenge)
	}
	if m.teacher_comment != nil {
		fields = append(fields, step.FieldTeacherComment)
	}
	if m.parent_comment != nil {
		fields = append(fields, step.FieldParentComment)
	}
	if m.friend_comment != nil {
		fields = append(fields, step.FieldFriendComment)
	}
	if m._type != nil {
		fields = append(fields, step.FieldType)
	}
	if m.object_name != nil {
		fields = append(fields, step.FieldObjectName)
	}
	if m.created_at != nil {
		fields = append(fields, step.FieldCreatedAt)
	}
	if m.target != nil {
		fields = append(fields, step.FieldRefTargetID)
	}
	if m.parent != nil {
		fields = append(fields, step.FieldParentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StepMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case step.FieldTitle:
		return m.Title()
	case step.FieldDescription:
		return m.Description()
	case step.FieldIsChallenge:
		return m.IsChallenge()
	case step.FieldTeacherComment:
		return m.TeacherComment()
	case step.FieldParentComment:
		return m.ParentComment()
	case step.FieldFriendComment:
		return m.FriendComment()
	case step.FieldType:
		return m.GetType()
	case step.FieldObjectName:
		return m.ObjectName()
	case step.FieldCreatedAt:
		return m.CreatedAt()
	case step.FieldRefTargetID:
		return m.RefTargetID()
	case step.FieldParentID:
		return m.ParentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StepMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case step.FieldTitle:
		return m.OldTitle(ctx)
	case step.FieldDescription:
		return m.OldDescription(ctx)
	case step.FieldIsChallenge:
		return m.OldIsChallenge(ctx)
	case step.FieldTeacherComment:
		return m.OldTeacherComment(ctx)
	case step.FieldParentComment:
		return m.OldParentComment(ctx)
	case step.FieldFriendComment:
		return m.OldFriendComment(ctx)
	case step.FieldType:
		return m.OldType(ctx)
	case step.FieldObjectName:
		return m.OldObjectName(ctx)
	case step.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case step.FieldRefTargetID:
		return m.OldRefTargetID(ctx)
	case step.FieldParentID:
		return m.OldParentID(ctx)
	}
	return nil, fmt.Errorf("unknown Step field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StepMutation) SetField(name string, value ent.Value) error {
	switch name {
	case step.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case step.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case step.FieldIsChallenge:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsChallenge(v)
		return nil
	case step.FieldTeacherComment:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeacherComment(v)
		return nil
	case step.FieldParentComment:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentComment(v)
		return nil
	case step.FieldFriendComment:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFriendComment(v)
		return nil
	case step.FieldType:
		v, ok := value.(step.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case step.FieldObjectName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObjectName(v)
		return nil
	case step.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case step.FieldRefTargetID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefTargetID(v)
		return nil
	case step.FieldParentID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	}
	return fmt.Errorf("unknown Step field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StepMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, step.FieldCreatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StepMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case step.FieldCreatedAt:
		return m.AddedCreatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StepMutation) AddField(name string, value ent.Value) error {
	switch name {
	case step.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Step numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StepMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(step.FieldTitle) {
		fields = append(fields, step.FieldTitle)
	}
	if m.FieldCleared(step.FieldDescription) {
		fields = append(fields, step.FieldDescription)
	}
	if m.FieldCleared(step.FieldTeacherComment) {
		fields = append(fields, step.FieldTeacherComment)
	}
	if m.FieldCleared(step.FieldParentComment) {
		fields = append(fields, step.FieldParentComment)
	}
	if m.FieldCleared(step.FieldFriendComment) {
		fields = append(fields, step.FieldFriendComment)
	}
	if m.FieldCleared(step.FieldObjectName) {
		fields = append(fields, step.FieldObjectName)
	}
	if m.FieldCleared(step.FieldRefTargetID) {
		fields = append(fields, step.FieldRefTargetID)
	}
	if m.FieldCleared(step.FieldParentID) {
		fields = append(fields, step.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StepMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StepMutation) ClearField(name string) error {
	switch name {
	case step.FieldTitle:
		m.ClearTitle()
		return nil
	case step.FieldDescription:
		m.ClearDescription()
		return nil
	case step.FieldTeacherComment:
		m.ClearTeacherComment()
		return nil
	case step.FieldParentComment:
		m.ClearParentComment()
		return nil
	case step.FieldFriendComment:
		m.ClearFriendComment()
		return nil
	case step.FieldObjectName:
		m.ClearObjectName()
		return nil
	case step.FieldRefTargetID:
		m.ClearRefTargetID()
		return nil
	case step.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown Step nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StepMutation) ResetField(name string) error {
	switch name {
	case step.FieldTitle:
		m.ResetTitle()
		return nil
	case step.FieldDescription:
		m.ResetDescription()
		return nil
	case step.FieldIsChallenge:
		m.ResetIsChallenge()
		return nil
	case step.FieldTeacherComment:
		m.ResetTeacherComment()
		return nil
	case step.FieldParentComment:
		m.ResetParentComment()
		return nil
	case step.FieldFriendComment:
		m.ResetFriendComment()
		return nil
	case step.FieldType:
		m.ResetType()
		return nil
	case step.FieldObjectName:
		m.ResetObjectName()
		return nil
	case step.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case step.FieldRefTargetID:
		m.ResetRefTargetID()
		return nil
	case step.FieldParentID:
		m.ResetParentID()
		return nil
	}
	return fmt.Errorf("unknown Step field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StepMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.target != nil {
		edges = append(edges, step.EdgeTarget)
	}
	if m.parent != nil {
		edges = append(edges, step.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, step.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StepMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case step.EdgeTarget:
		if id := m.target; id != nil {
			return []ent.Value{*id}
		}
	case step.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case step.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StepMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, step.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StepMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case step.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StepMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtarget {
		edges = append(edges, step.EdgeTarget)
	}
	if m.clearedparent {
		edges = append(edges, step.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, step.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StepMutation) EdgeCleared(name string) bool {
	switch name {
	case step.EdgeTarget:
		return m.clearedtarget
	case step.EdgeParent:
		return m.clearedparent
	case step.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StepMutation) ClearEdge(name string) error {
	switch name {
	case step.EdgeTarget:
		m.ClearTarget()
		return nil
	case step.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Step unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StepMutation) ResetEdge(name string) error {
	switch name {
	case step.EdgeTarget:
		m.ResetTarget()
		return nil
	case step.EdgeParent:
		m.ResetParent()
		return nil
	case step.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown Step edge %s", name)
}

// StepRateMutation represents an operation that mutates the StepRate nodes in the graph.
type StepRateMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uint64
	user_id                   *string
	top_target_id             *uint64
	addtop_target_id          *int64
	target_id                 *uint64
	addtarget_id              *int64
	step_id                   *uint64
	addstep_id                *int64
	weighted_value            *float64
	addweighted_value         *float64
	target_reasonableness     *int32
	addtarget_reasonableness  *int32
	target_clarity            *int32
	addtarget_clarity         *int32
	target_achievement        *int32
	addtarget_achievement     *int32
	reflection_improvement    *int32
	addreflection_improvement *int32
	innovation                *int32
	addinnovation             *int32
	basic_reliability         *int32
	addbasic_reliability      *int32
	skill_improvement         *int32
	addskill_improvement      *int32
	difficulty                *int32
	adddifficulty             *int32
	date                      *time.Time
	clearedFields             map[string]struct{}
	done                      bool
	oldValue                  func(context.Context) (*StepRate, error)
	predicates                []predicate.StepRate
}

var _ ent.Mutation = (*StepRateMutation)(nil)

// steprateOption allows management of the mutation configuration using functional options.
type steprateOption func(*StepRateMutation)

// newStepRateMutation creates new mutation for the StepRate entity.
func newStepRateMutation(c config, op Op, opts ...steprateOption) *StepRateMutation {
	m := &StepRateMutation{
		config:        c,
		op:            op,
		typ:           TypeStepRate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStepRateID sets the ID field of the mutation.
func withStepRateID(id uint64) steprateOption {
	return func(m *StepRateMutation) {
		var (
			err   error
			once  sync.Once
			value *StepRate
		)
		m.oldValue = func(ctx context.Context) (*StepRate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StepRate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStepRate sets the old StepRate of the mutation.
func withStepRate(node *StepRate) steprateOption {
	return func(m *StepRateMutation) {
		m.oldValue = func(context.Context) (*StepRate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StepRateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StepRateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StepRate entities.
func (m *StepRateMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StepRateMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StepRateMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StepRate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *StepRateMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *StepRateMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the StepRate entity.
// If the StepRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepRateMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *StepRateMutation) ResetUserID() {
	m.user_id = nil
}

// SetTopTargetID sets the "top_target_id" field.
func (m *StepRateMutation) SetTopTargetID(u uint64) {
	m.top_target_id = &u
	m.addtop_target_id = nil
}

// TopTargetID returns the value of the "top_target_id" field in the mutation.
func (m *StepRateMutation) TopTargetID() (r uint64, exists bool) {
	v := m.top_target_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTopTargetID returns the old "top_target_id" field's value of the StepRate entity.
// If the StepRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepRateMutation) OldTopTargetID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopTargetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopTargetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopTargetID: %w", err)
	}
	return oldValue.TopTargetID, nil
}

// AddTopTargetID adds u to the "top_target_id" field.
func (m *StepRateMutation) AddTopTargetID(u int64) {
	if m.addtop_target_id != nil {
		*m.addtop_target_id += u
	} else {
		m.addtop_target_id = &u
	}
}

// AddedTopTargetID returns the value that was added to the "top_target_id" field in this mutation.
func (m *StepRateMutation) AddedTopTargetID() (r int64, exists bool) {
	v := m.addtop_target_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTopTargetID resets all changes to the "top_target_id" field.
func (m *StepRateMutation) ResetTopTargetID() {
	m.top_target_id = nil
	m.addtop_target_id = nil
}

// SetTargetID sets the "target_id" field.
func (m *StepRateMutation) SetTargetID(u uint64) {
	m.target_id = &u
	m.addtarget_id = nil
}

// TargetID returns the value of the "target_id" field in the mutation.
func (m *StepRateMutation) TargetID() (r uint64, exists bool) {
	v := m.target_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetID returns the old "target_id" field's value of the StepRate entity.
// If the StepRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepRateMutation) OldTargetID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetID: %w", err)
	}
	return oldValue.TargetID, nil
}

// AddTargetID adds u to the "target_id" field.
func (m *StepRateMutation) AddTargetID(u int64) {
	if m.addtarget_id != nil {
		*m.addtarget_id += u
	} else {
		m.addtarget_id = &u
	}
}

// AddedTargetID returns the value that was added to the "target_id" field in this mutation.
func (m *StepRateMutation) AddedTargetID() (r int64, exists bool) {
	v := m.addtarget_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTargetID resets all changes to the "target_id" field.
func (m *StepRateMutation) ResetTargetID() {
	m.target_id = nil
	m.addtarget_id = nil
}

// SetStepID sets the "step_id" field.
func (m *StepRateMutation) SetStepID(u uint64) {
	m.step_id = &u
	m.addstep_id = nil
}

// StepID returns the value of the "step_id" field in the mutation.
func (m *StepRateMutation) StepID() (r uint64, exists bool) {
	v := m.step_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStepID returns the old "step_id" field's value of the StepRate entity.
// If the StepRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepRateMutation) OldStepID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepID: %w", err)
	}
	return oldValue.StepID, nil
}

// AddStepID adds u to the "step_id" field.
func (m *StepRateMutation) AddStepID(u int64) {
	if m.addstep_id != nil {
		*m.addstep_id += u
	} else {
		m.addstep_id = &u
	}
}

// AddedStepID returns the value that was added to the "step_id" field in this mutation.
func (m *StepRateMutation) AddedStepID() (r int64, exists bool) {
	v := m.addstep_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetStepID resets all changes to the "step_id" field.
func (m *StepRateMutation) ResetStepID() {
	m.step_id = nil
	m.addstep_id = nil
}

// SetWeightedValue sets the "weighted_value" field.
func (m *StepRateMutation) SetWeightedValue(f float64) {
	m.weighted_value = &f
	m.addweighted_value = nil
}

// WeightedValue returns the value of the "weighted_value" field in the mutation.
func (m *StepRateMutation) WeightedValue() (r float64, exists bool) {
	v := m.weighted_value
	if v == nil {
		return
	}
	return *v, true
}

// OldWeightedValue returns the old "weighted_value" field's value of the StepRate entity.
// If the StepRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepRateMutation) OldWeightedValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeightedValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeightedValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeightedValue: %w", err)
	}
	return oldValue.WeightedValue, nil
}

// AddWeightedValue adds f to the "weighted_value" field.
func (m *StepRateMutation) AddWeightedValue(f float64) {
	if m.addweighted_value != nil {
		*m.addweighted_value += f
	} else {
		m.addweighted_value = &f
	}
}

// AddedWeightedValue returns the value that was added to the "weighted_value" field in this mutation.
func (m *StepRateMutation) AddedWeightedValue() (r float64, exists bool) {
	v := m.addweighted_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeightedValue resets all changes to the "weighted_value" field.
func (m *StepRateMutation) ResetWeightedValue() {
	m.weighted_value = nil
	m.addweighted_value = nil
}

// SetTargetReasonableness sets the "target_reasonableness" field.
func (m *StepRateMutation) SetTargetReasonableness(i int32) {
	m.target_reasonableness = &i
	m.addtarget_reasonableness = nil
}

// TargetReasonableness returns the value of the "target_reasonableness" field in the mutation.
func (m *StepRateMutation) TargetReasonableness() (r int32, exists bool) {
	v := m.target_reasonableness
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetReasonableness returns the old "target_reasonableness" field's value of the StepRate entity.
// If the StepRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepRateMutation) OldTargetReasonableness(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetReasonableness is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetReasonableness requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetReasonableness: %w", err)
	}
	return oldValue.TargetReasonableness, nil
}

// AddTargetReasonableness adds i to the "target_reasonableness" field.
func (m *StepRateMutation) AddTargetReasonableness(i int32) {
	if m.addtarget_reasonableness != nil {
		*m.addtarget_reasonableness += i
	} else {
		m.addtarget_reasonableness = &i
	}
}

// AddedTargetReasonableness returns the value that was added to the "target_reasonableness" field in this mutation.
func (m *StepRateMutation) AddedTargetReasonableness() (r int32, exists bool) {
	v := m.addtarget_reasonableness
	if v == nil {
		return
	}
	return *v, true
}

// ResetTargetReasonableness resets all changes to the "target_reasonableness" field.
func (m *StepRateMutation) ResetTargetReasonableness() {
	m.target_reasonableness = nil
	m.addtarget_reasonableness = nil
}

// SetTargetClarity sets the "target_clarity" field.
func (m *StepRateMutation) SetTargetClarity(i int32) {
	m.target_clarity = &i
	m.addtarget_clarity = nil
}

// TargetClarity returns the value of the "target_clarity" field in the mutation.
func (m *StepRateMutation) TargetClarity() (r int32, exists bool) {
	v := m.target_clarity
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetClarity returns the old "target_clarity" field's value of the StepRate entity.
// If the StepRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepRateMutation) OldTargetClarity(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetClarity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetClarity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetClarity: %w", err)
	}
	return oldValue.TargetClarity, nil
}

// AddTargetClarity adds i to the "target_clarity" field.
func (m *StepRateMutation) AddTargetClarity(i int32) {
	if m.addtarget_clarity != nil {
		*m.addtarget_clarity += i
	} else {
		m.addtarget_clarity = &i
	}
}

// AddedTargetClarity returns the value that was added to the "target_clarity" field in this mutation.
func (m *StepRateMutation) AddedTargetClarity() (r int32, exists bool) {
	v := m.addtarget_clarity
	if v == nil {
		return
	}
	return *v, true
}

// ResetTargetClarity resets all changes to the "target_clarity" field.
func (m *StepRateMutation) ResetTargetClarity() {
	m.target_clarity = nil
	m.addtarget_clarity = nil
}

// SetTargetAchievement sets the "target_achievement" field.
func (m *StepRateMutation) SetTargetAchievement(i int32) {
	m.target_achievement = &i
	m.addtarget_achievement = nil
}

// TargetAchievement returns the value of the "target_achievement" field in the mutation.
func (m *StepRateMutation) TargetAchievement() (r int32, exists bool) {
	v := m.target_achievement
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetAchievement returns the old "target_achievement" field's value of the StepRate entity.
// If the StepRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepRateMutation) OldTargetAchievement(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetAchievement is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetAchievement requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetAchievement: %w", err)
	}
	return oldValue.TargetAchievement, nil
}

// AddTargetAchievement adds i to the "target_achievement" field.
func (m *StepRateMutation) AddTargetAchievement(i int32) {
	if m.addtarget_achievement != nil {
		*m.addtarget_achievement += i
	} else {
		m.addtarget_achievement = &i
	}
}

// AddedTargetAchievement returns the value that was added to the "target_achievement" field in this mutation.
func (m *StepRateMutation) AddedTargetAchievement() (r int32, exists bool) {
	v := m.addtarget_achievement
	if v == nil {
		return
	}
	return *v, true
}

// ResetTargetAchievement resets all changes to the "target_achievement" field.
func (m *StepRateMutation) ResetTargetAchievement() {
	m.target_achievement = nil
	m.addtarget_achievement = nil
}

// SetReflectionImprovement sets the "reflection_improvement" field.
func (m *StepRateMutation) SetReflectionImprovement(i int32) {
	m.reflection_improvement = &i
	m.addreflection_improvement = nil
}

// ReflectionImprovement returns the value of the "reflection_improvement" field in the mutation.
func (m *StepRateMutation) ReflectionImprovement() (r int32, exists bool) {
	v := m.reflection_improvement
	if v == nil {
		return
	}
	return *v, true
}

// OldReflectionImprovement returns the old "reflection_improvement" field's value of the StepRate entity.
// If the StepRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepRateMutation) OldReflectionImprovement(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReflectionImprovement is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReflectionImprovement requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReflectionImprovement: %w", err)
	}
	return oldValue.ReflectionImprovement, nil
}

// AddReflectionImprovement adds i to the "reflection_improvement" field.
func (m *StepRateMutation) AddReflectionImprovement(i int32) {
	if m.addreflection_improvement != nil {
		*m.addreflection_improvement += i
	} else {
		m.addreflection_improvement = &i
	}
}

// AddedReflectionImprovement returns the value that was added to the "reflection_improvement" field in this mutation.
func (m *StepRateMutation) AddedReflectionImprovement() (r int32, exists bool) {
	v := m.addreflection_improvement
	if v == nil {
		return
	}
	return *v, true
}

// ResetReflectionImprovement resets all changes to the "reflection_improvement" field.
func (m *StepRateMutation) ResetReflectionImprovement() {
	m.reflection_improvement = nil
	m.addreflection_improvement = nil
}

// SetInnovation sets the "innovation" field.
func (m *StepRateMutation) SetInnovation(i int32) {
	m.innovation = &i
	m.addinnovation = nil
}

// Innovation returns the value of the "innovation" field in the mutation.
func (m *StepRateMutation) Innovation() (r int32, exists bool) {
	v := m.innovation
	if v == nil {
		return
	}
	return *v, true
}

// OldInnovation returns the old "innovation" field's value of the StepRate entity.
// If the StepRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepRateMutation) OldInnovation(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInnovation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInnovation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInnovation: %w", err)
	}
	return oldValue.Innovation, nil
}

// AddInnovation adds i to the "innovation" field.
func (m *StepRateMutation) AddInnovation(i int32) {
	if m.addinnovation != nil {
		*m.addinnovation += i
	} else {
		m.addinnovation = &i
	}
}

// AddedInnovation returns the value that was added to the "innovation" field in this mutation.
func (m *StepRateMutation) AddedInnovation() (r int32, exists bool) {
	v := m.addinnovation
	if v == nil {
		return
	}
	return *v, true
}

// ResetInnovation resets all changes to the "innovation" field.
func (m *StepRateMutation) ResetInnovation() {
	m.innovation = nil
	m.addinnovation = nil
}

// SetBasicReliability sets the "basic_reliability" field.
func (m *StepRateMutation) SetBasicReliability(i int32) {
	m.basic_reliability = &i
	m.addbasic_reliability = nil
}

// BasicReliability returns the value of the "basic_reliability" field in the mutation.
func (m *StepRateMutation) BasicReliability() (r int32, exists bool) {
	v := m.basic_reliability
	if v == nil {
		return
	}
	return *v, true
}

// OldBasicReliability returns the old "basic_reliability" field's value of the StepRate entity.
// If the StepRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepRateMutation) OldBasicReliability(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBasicReliability is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBasicReliability requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBasicReliability: %w", err)
	}
	return oldValue.BasicReliability, nil
}

// AddBasicReliability adds i to the "basic_reliability" field.
func (m *StepRateMutation) AddBasicReliability(i int32) {
	if m.addbasic_reliability != nil {
		*m.addbasic_reliability += i
	} else {
		m.addbasic_reliability = &i
	}
}

// AddedBasicReliability returns the value that was added to the "basic_reliability" field in this mutation.
func (m *StepRateMutation) AddedBasicReliability() (r int32, exists bool) {
	v := m.addbasic_reliability
	if v == nil {
		return
	}
	return *v, true
}

// ResetBasicReliability resets all changes to the "basic_reliability" field.
func (m *StepRateMutation) ResetBasicReliability() {
	m.basic_reliability = nil
	m.addbasic_reliability = nil
}

// SetSkillImprovement sets the "skill_improvement" field.
func (m *StepRateMutation) SetSkillImprovement(i int32) {
	m.skill_improvement = &i
	m.addskill_improvement = nil
}

// SkillImprovement returns the value of the "skill_improvement" field in the mutation.
func (m *StepRateMutation) SkillImprovement() (r int32, exists bool) {
	v := m.skill_improvement
	if v == nil {
		return
	}
	return *v, true
}

// OldSkillImprovement returns the old "skill_improvement" field's value of the StepRate entity.
// If the StepRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepRateMutation) OldSkillImprovement(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkillImprovement is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkillImprovement requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkillImprovement: %w", err)
	}
	return oldValue.SkillImprovement, nil
}

// AddSkillImprovement adds i to the "skill_improvement" field.
func (m *StepRateMutation) AddSkillImprovement(i int32) {
	if m.addskill_improvement != nil {
		*m.addskill_improvement += i
	} else {
		m.addskill_improvement = &i
	}
}

// AddedSkillImprovement returns the value that was added to the "skill_improvement" field in this mutation.
func (m *StepRateMutation) AddedSkillImprovement() (r int32, exists bool) {
	v := m.addskill_improvement
	if v == nil {
		return
	}
	return *v, true
}

// ResetSkillImprovement resets all changes to the "skill_improvement" field.
func (m *StepRateMutation) ResetSkillImprovement() {
	m.skill_improvement = nil
	m.addskill_improvement = nil
}

// SetDifficulty sets the "difficulty" field.
func (m *StepRateMutation) SetDifficulty(i int32) {
	m.difficulty = &i
	m.adddifficulty = nil
}

// Difficulty returns the value of the "difficulty" field in the mutation.
func (m *StepRateMutation) Difficulty() (r int32, exists bool) {
	v := m.difficulty
	if v == nil {
		return
	}
	return *v, true
}

// OldDifficulty returns the old "difficulty" field's value of the StepRate entity.
// If the StepRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepRateMutation) OldDifficulty(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDifficulty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDifficulty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDifficulty: %w", err)
	}
	return oldValue.Difficulty, nil
}

// AddDifficulty adds i to the "difficulty" field.
func (m *StepRateMutation) AddDifficulty(i int32) {
	if m.adddifficulty != nil {
		*m.adddifficulty += i
	} else {
		m.adddifficulty = &i
	}
}

// AddedDifficulty returns the value that was added to the "difficulty" field in this mutation.
func (m *StepRateMutation) AddedDifficulty() (r int32, exists bool) {
	v := m.adddifficulty
	if v == nil {
		return
	}
	return *v, true
}

// ResetDifficulty resets all changes to the "difficulty" field.
func (m *StepRateMutation) ResetDifficulty() {
	m.difficulty = nil
	m.adddifficulty = nil
}

// SetDate sets the "date" field.
func (m *StepRateMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *StepRateMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the StepRate entity.
// If the StepRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepRateMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *StepRateMutation) ResetDate() {
	m.date = nil
}

// Where appends a list predicates to the StepRateMutation builder.
func (m *StepRateMutation) Where(ps ...predicate.StepRate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StepRateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StepRateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StepRate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StepRateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StepRateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StepRate).
func (m *StepRateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StepRateMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.user_id != nil {
		fields = append(fields, steprate.FieldUserID)
	}
	if m.top_target_id != nil {
		fields = append(fields, steprate.FieldTopTargetID)
	}
	if m.target_id != nil {
		fields = append(fields, steprate.FieldTargetID)
	}
	if m.step_id != nil {
		fields = append(fields, steprate.FieldStepID)
	}
	if m.weighted_value != nil {
		fields = append(fields, steprate.FieldWeightedValue)
	}
	if m.target_reasonableness != nil {
		fields = append(fields, steprate.FieldTargetReasonableness)
	}
	if m.target_clarity != nil {
		fields = append(fields, steprate.FieldTargetClarity)
	}
	if m.target_achievement != nil {
		fields = append(fields, steprate.FieldTargetAchievement)
	}
	if m.reflection_improvement != nil {
		fields = append(fields, steprate.FieldReflectionImprovement)
	}
	if m.innovation != nil {
		fields = append(fields, steprate.FieldInnovation)
	}
	if m.basic_reliability != nil {
		fields = append(fields, steprate.FieldBasicReliability)
	}
	if m.skill_improvement != nil {
		fields = append(fields, steprate.FieldSkillImprovement)
	}
	if m.difficulty != nil {
		fields = append(fields, steprate.FieldDifficulty)
	}
	if m.date != nil {
		fields = append(fields, steprate.FieldDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StepRateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case steprate.FieldUserID:
		return m.UserID()
	case steprate.FieldTopTargetID:
		return m.TopTargetID()
	case steprate.FieldTargetID:
		return m.TargetID()
	case steprate.FieldStepID:
		return m.StepID()
	case steprate.FieldWeightedValue:
		return m.WeightedValue()
	case steprate.FieldTargetReasonableness:
		return m.TargetReasonableness()
	case steprate.FieldTargetClarity:
		return m.TargetClarity()
	case steprate.FieldTargetAchievement:
		return m.TargetAchievement()
	case steprate.FieldReflectionImprovement:
		return m.ReflectionImprovement()
	case steprate.FieldInnovation:
		return m.Innovation()
	case steprate.FieldBasicReliability:
		return m.BasicReliability()
	case steprate.FieldSkillImprovement:
		return m.SkillImprovement()
	case steprate.FieldDifficulty:
		return m.Difficulty()
	case steprate.FieldDate:
		return m.Date()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StepRateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case steprate.FieldUserID:
		return m.OldUserID(ctx)
	case steprate.FieldTopTargetID:
		return m.OldTopTargetID(ctx)
	case steprate.FieldTargetID:
		return m.OldTargetID(ctx)
	case steprate.FieldStepID:
		return m.OldStepID(ctx)
	case steprate.FieldWeightedValue:
		return m.OldWeightedValue(ctx)
	case steprate.FieldTargetReasonableness:
		return m.OldTargetReasonableness(ctx)
	case steprate.FieldTargetClarity:
		return m.OldTargetClarity(ctx)
	case steprate.FieldTargetAchievement:
		return m.OldTargetAchievement(ctx)
	case steprate.FieldReflectionImprovement:
		return m.OldReflectionImprovement(ctx)
	case steprate.FieldInnovation:
		return m.OldInnovation(ctx)
	case steprate.FieldBasicReliability:
		return m.OldBasicReliability(ctx)
	case steprate.FieldSkillImprovement:
		return m.OldSkillImprovement(ctx)
	case steprate.FieldDifficulty:
		return m.OldDifficulty(ctx)
	case steprate.FieldDate:
		return m.OldDate(ctx)
	}
	return nil, fmt.Errorf("unknown StepRate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StepRateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case steprate.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case steprate.FieldTopTargetID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopTargetID(v)
		return nil
	case steprate.FieldTargetID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetID(v)
		return nil
	case steprate.FieldStepID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepID(v)
		return nil
	case steprate.FieldWeightedValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeightedValue(v)
		return nil
	case steprate.FieldTargetReasonableness:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetReasonableness(v)
		return nil
	case steprate.FieldTargetClarity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetClarity(v)
		return nil
	case steprate.FieldTargetAchievement:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetAchievement(v)
		return nil
	case steprate.FieldReflectionImprovement:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReflectionImprovement(v)
		return nil
	case steprate.FieldInnovation:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInnovation(v)
		return nil
	case steprate.FieldBasicReliability:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBasicReliability(v)
		return nil
	case steprate.FieldSkillImprovement:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkillImprovement(v)
		return nil
	case steprate.FieldDifficulty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDifficulty(v)
		return nil
	case steprate.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	}
	return fmt.Errorf("unknown StepRate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StepRateMutation) AddedFields() []string {
	var fields []string
	if m.addtop_target_id != nil {
		fields = append(fields, steprate.FieldTopTargetID)
	}
	if m.addtarget_id != nil {
		fields = append(fields, steprate.FieldTargetID)
	}
	if m.addstep_id != nil {
		fields = append(fields, steprate.FieldStepID)
	}
	if m.addweighted_value != nil {
		fields = append(fields, steprate.FieldWeightedValue)
	}
	if m.addtarget_reasonableness != nil {
		fields = append(fields, steprate.FieldTargetReasonableness)
	}
	if m.addtarget_clarity != nil {
		fields = append(fields, steprate.FieldTargetClarity)
	}
	if m.addtarget_achievement != nil {
		fields = append(fields, steprate.FieldTargetAchievement)
	}
	if m.addreflection_improvement != nil {
		fields = append(fields, steprate.FieldReflectionImprovement)
	}
	if m.addinnovation != nil {
		fields = append(fields, steprate.FieldInnovation)
	}
	if m.addbasic_reliability != nil {
		fields = append(fields, steprate.FieldBasicReliability)
	}
	if m.addskill_improvement != nil {
		fields = append(fields, steprate.FieldSkillImprovement)
	}
	if m.adddifficulty != nil {
		fields = append(fields, steprate.FieldDifficulty)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StepRateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case steprate.FieldTopTargetID:
		return m.AddedTopTargetID()
	case steprate.FieldTargetID:
		return m.AddedTargetID()
	case steprate.FieldStepID:
		return m.AddedStepID()
	case steprate.FieldWeightedValue:
		return m.AddedWeightedValue()
	case steprate.FieldTargetReasonableness:
		return m.AddedTargetReasonableness()
	case steprate.FieldTargetClarity:
		return m.AddedTargetClarity()
	case steprate.FieldTargetAchievement:
		return m.AddedTargetAchievement()
	case steprate.FieldReflectionImprovement:
		return m.AddedReflectionImprovement()
	case steprate.FieldInnovation:
		return m.AddedInnovation()
	case steprate.FieldBasicReliability:
		return m.AddedBasicReliability()
	case steprate.FieldSkillImprovement:
		return m.AddedSkillImprovement()
	case steprate.FieldDifficulty:
		return m.AddedDifficulty()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StepRateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case steprate.FieldTopTargetID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTopTargetID(v)
		return nil
	case steprate.FieldTargetID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTargetID(v)
		return nil
	case steprate.FieldStepID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStepID(v)
		return nil
	case steprate.FieldWeightedValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeightedValue(v)
		return nil
	case steprate.FieldTargetReasonableness:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTargetReasonableness(v)
		return nil
	case steprate.FieldTargetClarity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTargetClarity(v)
		return nil
	case steprate.FieldTargetAchievement:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTargetAchievement(v)
		return nil
	case steprate.FieldReflectionImprovement:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReflectionImprovement(v)
		return nil
	case steprate.FieldInnovation:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInnovation(v)
		return nil
	case steprate.FieldBasicReliability:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBasicReliability(v)
		return nil
	case steprate.FieldSkillImprovement:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSkillImprovement(v)
		return nil
	case steprate.FieldDifficulty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDifficulty(v)
		return nil
	}
	return fmt.Errorf("unknown StepRate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StepRateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StepRateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StepRateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StepRate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StepRateMutation) ResetField(name string) error {
	switch name {
	case steprate.FieldUserID:
		m.ResetUserID()
		return nil
	case steprate.FieldTopTargetID:
		m.ResetTopTargetID()
		return nil
	case steprate.FieldTargetID:
		m.ResetTargetID()
		return nil
	case steprate.FieldStepID:
		m.ResetStepID()
		return nil
	case steprate.FieldWeightedValue:
		m.ResetWeightedValue()
		return nil
	case steprate.FieldTargetReasonableness:
		m.ResetTargetReasonableness()
		return nil
	case steprate.FieldTargetClarity:
		m.ResetTargetClarity()
		return nil
	case steprate.FieldTargetAchievement:
		m.ResetTargetAchievement()
		return nil
	case steprate.FieldReflectionImprovement:
		m.ResetReflectionImprovement()
		return nil
	case steprate.FieldInnovation:
		m.ResetInnovation()
		return nil
	case steprate.FieldBasicReliability:
		m.ResetBasicReliability()
		return nil
	case steprate.FieldSkillImprovement:
		m.ResetSkillImprovement()
		return nil
	case steprate.FieldDifficulty:
		m.ResetDifficulty()
		return nil
	case steprate.FieldDate:
		m.ResetDate()
		return nil
	}
	return fmt.Errorf("unknown StepRate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StepRateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StepRateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StepRateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StepRateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StepRateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StepRateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StepRateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown StepRate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StepRateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown StepRate edge %s", name)
}

// TargetMutation represents an operation that mutates the Target nodes in the graph.
type TargetMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	user_id         *string
	title           *string
	description     *string
	_type           *string
	created_at      *int64
	addcreated_at   *int64
	start_at        *int64
	addstart_at     *int64
	challenge_at    *int64
	addchallenge_at *int64
	done_at         *int64
	adddone_at      *int64
	layer           *uint32
	addlayer        *int32
	status          *target.Status
	clearedFields   map[string]struct{}
	parent          *uint64
	clearedparent   bool
	children        map[uint64]struct{}
	removedchildren map[uint64]struct{}
	clearedchildren bool
	steps           map[uint64]struct{}
	removedsteps    map[uint64]struct{}
	clearedsteps    bool
	done            bool
	oldValue        func(context.Context) (*Target, error)
	predicates      []predicate.Target
}

var _ ent.Mutation = (*TargetMutation)(nil)

// targetOption allows management of the mutation configuration using functional options.
type targetOption func(*TargetMutation)

// newTargetMutation creates new mutation for the Target entity.
func newTargetMutation(c config, op Op, opts ...targetOption) *TargetMutation {
	m := &TargetMutation{
		config:        c,
		op:            op,
		typ:           TypeTarget,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTargetID sets the ID field of the mutation.
func withTargetID(id uint64) targetOption {
	return func(m *TargetMutation) {
		var (
			err   error
			once  sync.Once
			value *Target
		)
		m.oldValue = func(ctx context.Context) (*Target, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Target.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTarget sets the old Target of the mutation.
func withTarget(node *Target) targetOption {
	return func(m *TargetMutation) {
		m.oldValue = func(context.Context) (*Target, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TargetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TargetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Target entities.
func (m *TargetMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TargetMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TargetMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Target.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *TargetMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TargetMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Target entity.
// If the Target object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TargetMutation) ResetUserID() {
	m.user_id = nil
}

// SetTitle sets the "title" field.
func (m *TargetMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TargetMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Target entity.
// If the Target object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TargetMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *TargetMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TargetMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Target entity.
// If the Target object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TargetMutation) ResetDescription() {
	m.description = nil
}

// SetType sets the "type" field.
func (m *TargetMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *TargetMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Target entity.
// If the Target object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TargetMutation) ResetType() {
	m._type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TargetMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TargetMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Target entity.
// If the Target object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *TargetMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TargetMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TargetMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetStartAt sets the "start_at" field.
func (m *TargetMutation) SetStartAt(i int64) {
	m.start_at = &i
	m.addstart_at = nil
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *TargetMutation) StartAt() (r int64, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Target entity.
// If the Target object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMutation) OldStartAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// AddStartAt adds i to the "start_at" field.
func (m *TargetMutation) AddStartAt(i int64) {
	if m.addstart_at != nil {
		*m.addstart_at += i
	} else {
		m.addstart_at = &i
	}
}

// AddedStartAt returns the value that was added to the "start_at" field in this mutation.
func (m *TargetMutation) AddedStartAt() (r int64, exists bool) {
	v := m.addstart_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartAt clears the value of the "start_at" field.
func (m *TargetMutation) ClearStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	m.clearedFields[target.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *TargetMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[target.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *TargetMutation) ResetStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	delete(m.clearedFields, target.FieldStartAt)
}

// SetChallengeAt sets the "challenge_at" field.
func (m *TargetMutation) SetChallengeAt(i int64) {
	m.challenge_at = &i
	m.addchallenge_at = nil
}

// ChallengeAt returns the value of the "challenge_at" field in the mutation.
func (m *TargetMutation) ChallengeAt() (r int64, exists bool) {
	v := m.challenge_at
	if v == nil {
		return
	}
	return *v, true
}

// OldChallengeAt returns the old "challenge_at" field's value of the Target entity.
// If the Target object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMutation) OldChallengeAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChallengeAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChallengeAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChallengeAt: %w", err)
	}
	return oldValue.ChallengeAt, nil
}

// AddChallengeAt adds i to the "challenge_at" field.
func (m *TargetMutation) AddChallengeAt(i int64) {
	if m.addchallenge_at != nil {
		*m.addchallenge_at += i
	} else {
		m.addchallenge_at = &i
	}
}

// AddedChallengeAt returns the value that was added to the "challenge_at" field in this mutation.
func (m *TargetMutation) AddedChallengeAt() (r int64, exists bool) {
	v := m.addchallenge_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearChallengeAt clears the value of the "challenge_at" field.
func (m *TargetMutation) ClearChallengeAt() {
	m.challenge_at = nil
	m.addchallenge_at = nil
	m.clearedFields[target.FieldChallengeAt] = struct{}{}
}

// ChallengeAtCleared returns if the "challenge_at" field was cleared in this mutation.
func (m *TargetMutation) ChallengeAtCleared() bool {
	_, ok := m.clearedFields[target.FieldChallengeAt]
	return ok
}

// ResetChallengeAt resets all changes to the "challenge_at" field.
func (m *TargetMutation) ResetChallengeAt() {
	m.challenge_at = nil
	m.addchallenge_at = nil
	delete(m.clearedFields, target.FieldChallengeAt)
}

// SetDoneAt sets the "done_at" field.
func (m *TargetMutation) SetDoneAt(i int64) {
	m.done_at = &i
	m.adddone_at = nil
}

// DoneAt returns the value of the "done_at" field in the mutation.
func (m *TargetMutation) DoneAt() (r int64, exists bool) {
	v := m.done_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDoneAt returns the old "done_at" field's value of the Target entity.
// If the Target object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMutation) OldDoneAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDoneAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDoneAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoneAt: %w", err)
	}
	return oldValue.DoneAt, nil
}

// AddDoneAt adds i to the "done_at" field.
func (m *TargetMutation) AddDoneAt(i int64) {
	if m.adddone_at != nil {
		*m.adddone_at += i
	} else {
		m.adddone_at = &i
	}
}

// AddedDoneAt returns the value that was added to the "done_at" field in this mutation.
func (m *TargetMutation) AddedDoneAt() (r int64, exists bool) {
	v := m.adddone_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearDoneAt clears the value of the "done_at" field.
func (m *TargetMutation) ClearDoneAt() {
	m.done_at = nil
	m.adddone_at = nil
	m.clearedFields[target.FieldDoneAt] = struct{}{}
}

// DoneAtCleared returns if the "done_at" field was cleared in this mutation.
func (m *TargetMutation) DoneAtCleared() bool {
	_, ok := m.clearedFields[target.FieldDoneAt]
	return ok
}

// ResetDoneAt resets all changes to the "done_at" field.
func (m *TargetMutation) ResetDoneAt() {
	m.done_at = nil
	m.adddone_at = nil
	delete(m.clearedFields, target.FieldDoneAt)
}

// SetLayer sets the "layer" field.
func (m *TargetMutation) SetLayer(u uint32) {
	m.layer = &u
	m.addlayer = nil
}

// Layer returns the value of the "layer" field in the mutation.
func (m *TargetMutation) Layer() (r uint32, exists bool) {
	v := m.layer
	if v == nil {
		return
	}
	return *v, true
}

// OldLayer returns the old "layer" field's value of the Target entity.
// If the Target object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMutation) OldLayer(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLayer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLayer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLayer: %w", err)
	}
	return oldValue.Layer, nil
}

// AddLayer adds u to the "layer" field.
func (m *TargetMutation) AddLayer(u int32) {
	if m.addlayer != nil {
		*m.addlayer += u
	} else {
		m.addlayer = &u
	}
}

// AddedLayer returns the value that was added to the "layer" field in this mutation.
func (m *TargetMutation) AddedLayer() (r int32, exists bool) {
	v := m.addlayer
	if v == nil {
		return
	}
	return *v, true
}

// ResetLayer resets all changes to the "layer" field.
func (m *TargetMutation) ResetLayer() {
	m.layer = nil
	m.addlayer = nil
}

// SetStatus sets the "status" field.
func (m *TargetMutation) SetStatus(t target.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TargetMutation) Status() (r target.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Target entity.
// If the Target object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMutation) OldStatus(ctx context.Context) (v target.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TargetMutation) ResetStatus() {
	m.status = nil
}

// SetParentID sets the "parent_id" field.
func (m *TargetMutation) SetParentID(u uint64) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *TargetMutation) ParentID() (r uint64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Target entity.
// If the Target object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMutation) OldParentID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *TargetMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[target.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *TargetMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[target.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *TargetMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, target.FieldParentID)
}

// ClearParent clears the "parent" edge to the Target entity.
func (m *TargetMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[target.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Target entity was cleared.
func (m *TargetMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *TargetMutation) ParentIDs() (ids []uint64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *TargetMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Target entity by ids.
func (m *TargetMutation) AddChildIDs(ids ...uint64) {
	if m.children == nil {
		m.children = make(map[uint64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Target entity.
func (m *TargetMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Target entity was cleared.
func (m *TargetMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Target entity by IDs.
func (m *TargetMutation) RemoveChildIDs(ids ...uint64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Target entity.
func (m *TargetMutation) RemovedChildrenIDs() (ids []uint64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *TargetMutation) ChildrenIDs() (ids []uint64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *TargetMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddStepIDs adds the "steps" edge to the Step entity by ids.
func (m *TargetMutation) AddStepIDs(ids ...uint64) {
	if m.steps == nil {
		m.steps = make(map[uint64]struct{})
	}
	for i := range ids {
		m.steps[ids[i]] = struct{}{}
	}
}

// ClearSteps clears the "steps" edge to the Step entity.
func (m *TargetMutation) ClearSteps() {
	m.clearedsteps = true
}

// StepsCleared reports if the "steps" edge to the Step entity was cleared.
func (m *TargetMutation) StepsCleared() bool {
	return m.clearedsteps
}

// RemoveStepIDs removes the "steps" edge to the Step entity by IDs.
func (m *TargetMutation) RemoveStepIDs(ids ...uint64) {
	if m.removedsteps == nil {
		m.removedsteps = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.steps, ids[i])
		m.removedsteps[ids[i]] = struct{}{}
	}
}

// RemovedSteps returns the removed IDs of the "steps" edge to the Step entity.
func (m *TargetMutation) RemovedStepsIDs() (ids []uint64) {
	for id := range m.removedsteps {
		ids = append(ids, id)
	}
	return
}

// StepsIDs returns the "steps" edge IDs in the mutation.
func (m *TargetMutation) StepsIDs() (ids []uint64) {
	for id := range m.steps {
		ids = append(ids, id)
	}
	return
}

// ResetSteps resets all changes to the "steps" edge.
func (m *TargetMutation) ResetSteps() {
	m.steps = nil
	m.clearedsteps = false
	m.removedsteps = nil
}

// Where appends a list predicates to the TargetMutation builder.
func (m *TargetMutation) Where(ps ...predicate.Target) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TargetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TargetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Target, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TargetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TargetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Target).
func (m *TargetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TargetMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.user_id != nil {
		fields = append(fields, target.FieldUserID)
	}
	if m.title != nil {
		fields = append(fields, target.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, target.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, target.FieldType)
	}
	if m.created_at != nil {
		fields = append(fields, target.FieldCreatedAt)
	}
	if m.start_at != nil {
		fields = append(fields, target.FieldStartAt)
	}
	if m.challenge_at != nil {
		fields = append(fields, target.FieldChallengeAt)
	}
	if m.done_at != nil {
		fields = append(fields, target.FieldDoneAt)
	}
	if m.layer != nil {
		fields = append(fields, target.FieldLayer)
	}
	if m.status != nil {
		fields = append(fields, target.FieldStatus)
	}
	if m.parent != nil {
		fields = append(fields, target.FieldParentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TargetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case target.FieldUserID:
		return m.UserID()
	case target.FieldTitle:
		return m.Title()
	case target.FieldDescription:
		return m.Description()
	case target.FieldType:
		return m.GetType()
	case target.FieldCreatedAt:
		return m.CreatedAt()
	case target.FieldStartAt:
		return m.StartAt()
	case target.FieldChallengeAt:
		return m.ChallengeAt()
	case target.FieldDoneAt:
		return m.DoneAt()
	case target.FieldLayer:
		return m.Layer()
	case target.FieldStatus:
		return m.Status()
	case target.FieldParentID:
		return m.ParentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TargetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case target.FieldUserID:
		return m.OldUserID(ctx)
	case target.FieldTitle:
		return m.OldTitle(ctx)
	case target.FieldDescription:
		return m.OldDescription(ctx)
	case target.FieldType:
		return m.OldType(ctx)
	case target.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case target.FieldStartAt:
		return m.OldStartAt(ctx)
	case target.FieldChallengeAt:
		return m.OldChallengeAt(ctx)
	case target.FieldDoneAt:
		return m.OldDoneAt(ctx)
	case target.FieldLayer:
		return m.OldLayer(ctx)
	case target.FieldStatus:
		return m.OldStatus(ctx)
	case target.FieldParentID:
		return m.OldParentID(ctx)
	}
	return nil, fmt.Errorf("unknown Target field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TargetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case target.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case target.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case target.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case target.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case target.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case target.FieldStartAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case target.FieldChallengeAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChallengeAt(v)
		return nil
	case target.FieldDoneAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoneAt(v)
		return nil
	case target.FieldLayer:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLayer(v)
		return nil
	case target.FieldStatus:
		v, ok := value.(target.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case target.FieldParentID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	}
	return fmt.Errorf("unknown Target field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TargetMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, target.FieldCreatedAt)
	}
	if m.addstart_at != nil {
		fields = append(fields, target.FieldStartAt)
	}
	if m.addchallenge_at != nil {
		fields = append(fields, target.FieldChallengeAt)
	}
	if m.adddone_at != nil {
		fields = append(fields, target.FieldDoneAt)
	}
	if m.addlayer != nil {
		fields = append(fields, target.FieldLayer)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TargetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case target.FieldCreatedAt:
		return m.AddedCreatedAt()
	case target.FieldStartAt:
		return m.AddedStartAt()
	case target.FieldChallengeAt:
		return m.AddedChallengeAt()
	case target.FieldDoneAt:
		return m.AddedDoneAt()
	case target.FieldLayer:
		return m.AddedLayer()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TargetMutation) AddField(name string, value ent.Value) error {
	switch name {
	case target.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case target.FieldStartAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartAt(v)
		return nil
	case target.FieldChallengeAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChallengeAt(v)
		return nil
	case target.FieldDoneAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDoneAt(v)
		return nil
	case target.FieldLayer:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLayer(v)
		return nil
	}
	return fmt.Errorf("unknown Target numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TargetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(target.FieldStartAt) {
		fields = append(fields, target.FieldStartAt)
	}
	if m.FieldCleared(target.FieldChallengeAt) {
		fields = append(fields, target.FieldChallengeAt)
	}
	if m.FieldCleared(target.FieldDoneAt) {
		fields = append(fields, target.FieldDoneAt)
	}
	if m.FieldCleared(target.FieldParentID) {
		fields = append(fields, target.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TargetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TargetMutation) ClearField(name string) error {
	switch name {
	case target.FieldStartAt:
		m.ClearStartAt()
		return nil
	case target.FieldChallengeAt:
		m.ClearChallengeAt()
		return nil
	case target.FieldDoneAt:
		m.ClearDoneAt()
		return nil
	case target.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown Target nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TargetMutation) ResetField(name string) error {
	switch name {
	case target.FieldUserID:
		m.ResetUserID()
		return nil
	case target.FieldTitle:
		m.ResetTitle()
		return nil
	case target.FieldDescription:
		m.ResetDescription()
		return nil
	case target.FieldType:
		m.ResetType()
		return nil
	case target.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case target.FieldStartAt:
		m.ResetStartAt()
		return nil
	case target.FieldChallengeAt:
		m.ResetChallengeAt()
		return nil
	case target.FieldDoneAt:
		m.ResetDoneAt()
		return nil
	case target.FieldLayer:
		m.ResetLayer()
		return nil
	case target.FieldStatus:
		m.ResetStatus()
		return nil
	case target.FieldParentID:
		m.ResetParentID()
		return nil
	}
	return fmt.Errorf("unknown Target field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TargetMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, target.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, target.EdgeChildren)
	}
	if m.steps != nil {
		edges = append(edges, target.EdgeSteps)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TargetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case target.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case target.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case target.EdgeSteps:
		ids := make([]ent.Value, 0, len(m.steps))
		for id := range m.steps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TargetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, target.EdgeChildren)
	}
	if m.removedsteps != nil {
		edges = append(edges, target.EdgeSteps)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TargetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case target.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case target.EdgeSteps:
		ids := make([]ent.Value, 0, len(m.removedsteps))
		for id := range m.removedsteps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TargetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, target.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, target.EdgeChildren)
	}
	if m.clearedsteps {
		edges = append(edges, target.EdgeSteps)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TargetMutation) EdgeCleared(name string) bool {
	switch name {
	case target.EdgeParent:
		return m.clearedparent
	case target.EdgeChildren:
		return m.clearedchildren
	case target.EdgeSteps:
		return m.clearedsteps
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TargetMutation) ClearEdge(name string) error {
	switch name {
	case target.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Target unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TargetMutation) ResetEdge(name string) error {
	switch name {
	case target.EdgeParent:
		m.ResetParent()
		return nil
	case target.EdgeChildren:
		m.ResetChildren()
		return nil
	case target.EdgeSteps:
		m.ResetSteps()
		return nil
	}
	return fmt.Errorf("unknown Target edge %s", name)
}
